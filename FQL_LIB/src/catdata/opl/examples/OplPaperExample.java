package catdata.opl.examples;

import catdata.ide.Example;
import catdata.ide.Language;

public class OplPaperExample extends Example {

	@Override
	public String getName() {
		return "Paper";
	}

	@Override
	public String getText() {
		return s;
	}

	@Override
	public Language lang() {
		return Language.OPL;
	}
	
	String s = "TypeSide = theory {"
			+ "\n	sorts "
			+ "\n		Nat, Bool, Char, Str;"
			+ "\n	symbols"
			+ "\n		zero@7 : Nat, "
			+ "\n		succ@8 : Nat -> Nat,"
			+ "\n       	\"+\"@9, \"*\"@10 : Nat, Nat -> Nat, //the @ define an operator precedence"
			+ "\n"
			+ "\n        	\"<=\" : Nat, Nat -> Bool,"
			+ "\n        	true, false : Bool,"
			+ "\n"
			+ "\n        	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z : Char, //etc"
			+ "\n        	\" \" : Str,"
			+ "\n        	\"\" : Char, Str -> Str;"
			+ "\n    equations     "
			+ "\n		forall x. (0 \"+\" x) = x,"
			+ "\n    		forall x, y. (succ(x) \"+\" y) = succ((x \"+\" y)),"
			+ "\n    		forall x. (0 \"*\" x) = 0,"
			+ "\n//    		forall x. (S(O) \"*\" x) = x, wtf"
			+ "\n    		forall x, y. (succ(x) \"*\" y) = (x \"+\" (x \"*\" y)),"
			+ "\n"
			+ "\n    		forall x. (0 \"<=\" x) = true,"
			+ "\n    		forall x. (succ(x) \"<=\" 0) = false,"
			+ "\n    		forall x, y. (succ(x) \"<=\" succ(y)) = (x \"<=\" y);"
			+ "\n}"
			+ "\n"
			+ "\nSchema = SCHEMA {"
			+ "\n	entities"
			+ "\n	      Emp, Dept;"
			+ "\n	edges   "
			+ "\n      	mgr : Emp -> Emp,"
			+ "\n          wrk : Emp -> Dept,"
			+ "\n          sec : Dept -> Emp;"
			+ "\n	attributes"
			+ "\n          last@22 : Emp -> Str,"
			+ "\n          name@21 : Dept -> Str,"
			+ "\n          sal@20  : Emp -> Nat;"
			+ "\n	pathEqualities"
			+ "\n		forall e. e.mgr.mgr = e.mgr,"
			+ "\n		forall e. e.mgr.wrk = e.wrk,"
			+ "\n		forall d. d.sec.wrk = d;"
			+ "\n	obsEqualities	"
			+ "\n		forall e. (e.sal \"<=\" e.mgr.sal) = true;"
			+ "\n} : TypeSide"
			+ "\n"
			+ "\n"
			+ "\n//a random instance I found in the paper"
			+ "\nI = INSTANCE {"
			+ "\n      generators "
			+ "\n      	e : Emp, d : Dept;"
			+ "\n      equations "
			+ "\n      	e.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))),"
			+ "\n          (e.sal \"<=\" d.sec.sal) = true;"
			+ "\n} : Schema"
			+ "\n"
			+ "\nExample63 = INSTANCE {"
			+ "\n      generators "
			+ "\n      	e1, e2, e3, e4, e5, e6, e7 : Emp, "
			+ "\n      	d1, d2, d3 : Dept;"
			+ "\n      equations "
			+ "\n      	d1.name = \"\"(H, \"\"(R, \" \")), "
			+ "\n      	d1.sec = e3, "
			+ "\n      	"
			+ "\n      	d2.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))), "
			+ "\n      	d2.sec = e6,"
			+ "\n      	"
			+ "\n      	d3.name = \"\"(I, \"\"(T, \" \")), "
			+ "\n      	d3.sec = e5,"
			+ "\n      	"
			+ "\n		e1.last = \"\"(G, \"\"(A, \"\"(U, \"\"(S, \"\"(S, \" \"))))),"
			+ "\n		e1.wrk = d3, e1.mgr = e1, "
			+ "\n"
			+ "\n		e2.last = \"\"(N, \"\"(O, \"\"(E, \"\"(T, \"\"(H, \"\"(E, \"\"(R, \" \"))))))),"
			+ "\n		e2.wrk = d2, e2.mgr = e4,"
			+ "\n		"
			+ "\n		e3.last = \"\"(E, \"\"(I, \"\"(N, \"\"(S, \"\"(T, \"\"(E, \"\"(I, \"\"(N, \" \")))))))),"
			+ "\n		e3.wrk = d1, e3.mgr = e3,"
			+ "\n"
			+ "\n		e4.last = \"\"(T, \"\"(U, \"\"(R, \"\"(I, \"\"(N, \"\"(G, \" \")))))),"
			+ "\n		e4.wrk = d2, e4.mgr = e4,"
			+ "\n"
			+ "\n		e5.last = \"\"(N, \"\"(E, \"\"(W, \"\"(T, \"\"(O, \"\"(N, \" \")))))),"
			+ "\n		e5.wrk = d3, e5.mgr = e1,"
			+ "\n"
			+ "\n		e6.last = \"\"(E, \"\"(U, \"\"(C, \"\"(L, \"\"(I, \"\"(D, \" \")))))),"
			+ "\n		e6.wrk = d2, e6.mgr = e7,"
			+ "\n		"
			+ "\n		e7.last = \"\"(H, \"\"(Y, \"\"(P, \"\"(A, \"\"(T, \"\"(I, \"\"(A, \" \"))))))),"
			+ "\n		e7.wrk = d2, e7.mgr = e7,"
			+ "\n"
			+ "\n		e5.sal = 0, e6.sal = 1, e2.sal = 2, e1.sal = 3, e3.sal = 4, e4.sal = 5;"
			+ "\n} : Schema "
			+ "\n	"
			+ "\n"
			+ "\nSchema2 = SCHEMA {"
			+ "\n      entities"
			+ "\n	      Emp;"
			+ "\n	 edges;"
			+ "\n      attributes "
			+ "\n              sal : Emp -> Nat;"
			+ "\n      pathEqualities;"
			+ "\n      obsEqualities;"
			+ "\n} : TypeSide"
			+ "\n"
			+ "\n//an uber-flower I made up.  "
			+ "\n Q = query {"
			+ "\n       qEmp = {for e:Emp;"
			+ "\n                  where (e.sal \"<=\" e.wrk.sec.sal) = true;"
			+ "\n                  return sal = succ(e.sal);"
			+ "\n                  keys;} : Emp"
			+ "\n} : Schema -> Schema2 "
			+ "\n"
			+ "\nJ = apply Q Example63"
			+ "\n"
			+ "\nm = mapping {"
			+ "\nsorts Emp -> Emp;"
			+ "\nsymbols sal -> forall x. x.sal;"
			+ "\n} : Schema2 -> Schema"
			+ "\n";



}
