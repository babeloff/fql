package fql_lib.examples;

import fql_lib.core.Example;
import fql_lib.core.Language;

public class Patrick27ExampleIntegration extends Example {

	@Override
	public Language lang() {
		return Language.FPQL;
	}

	
	@Override
	public String getName() {
		return "Integration";
	}

	@Override
	public String getText() {
		return s;
	}
	
	String s ="//Example via Peter Gates"
			+ "\n/* **********************************************************"
			+ "\nIMPORTANT IMPORTANT IMPORTANT : Requires disabling type checking to run"
			+ "\n/********************************************************* */"
			+ "\n//Types:"
			+ "\ndom:type"
			+ "\nxPeter xPaul xM xF xBloodPressure xBodyWeight xHeartRate xPete xJane  : dom"
			+ "\n"
			+ "\n//Input schemas:"
			+ "\n"
			+ "\nOverlapSch = schema {"
			+ "\n nodes"
			+ "\n	O,P,T;"
			+ "\n edges"
			+ "\n	f:O->P,g:O->T;"
			+ "\n equations; "
			+ "\n}"
			+ "\n"
			+ "\nSch1 = schema {"
			+ "\n	nodes Observation, Person, Gender, ObsType;"
			+ "\n	edges f:Observation->Person, h:Person->Gender, g:Observation->ObsType,"
			+ "\n	      Person_att:Person->dom, Gender_att:Gender->dom, ObsType_att:ObsType->dom;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nSch2 = schema {"
			+ "\n	nodes Observation, Patient, Method, Type;"
			+ "\n	edges f:Observation->Patient, g1:Observation->Method, g2:Method->Type,"
			+ "\n	      Patient_att:Patient->dom, Type_att:Type->dom;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n// Input instances:"
			+ "\n"
			+ "\nOvInst=instance {"
			+ "\n	  variables Peter:P, BloodPressure:T, BodyWeight:T;"
			+ "\n	  equations;"
			+ "\n} 	: OverlapSch"
			+ "\n"
			+ "\nInst1=instance {"
			+ "\n	    variables"
			+ "\n	    1:Observation, 2:Observation, 3:Observation,"
			+ "\n	    Peter:Person, Paul:Person,"
			+ "\n	    M:Gender, F:Gender,"
			+ "\n	    BloodPressure: ObsType, BodyWeight:ObsType, HeartRate:ObsType; "
			+ "\n	equations"
			+ "\n		Peter.Person_att=xPeter, Paul.Person_att=xPaul,"
			+ "\n		M.Gender_att=xM, F.Gender_att=xF,"
			+ "\n		BloodPressure.ObsType_att=xBloodPressure, "
			+ "\n		BodyWeight.ObsType_att=xBodyWeight,"
			+ "\n		HeartRate.ObsType_att=xHeartRate,"
			+ "\n		1.f = Peter, 2.f = Peter, 3.f = Paul,"
			+ "\n		Peter.h = M, Paul.h = M,"
			+ "\n		1.g=BloodPressure, 2.g=BodyWeight, 3.g=HeartRate;"
			+ "\n}	: Sch1"
			+ "\n"
			+ "\nInst2 = instance {"
			+ "\n	    variables"
			+ "\n	    	    1:Observation, 2:Observation, 3:Observation, 4:Observation,"
			+ "\n		    Pete:Patient, Jane:Patient,"
			+ "\n		    1:Method, 2:Method, 3:Method, 4:Method,"
			+ "\n		    BP:Type, Wt:Type;"
			+ "\n	    equations"
			+ "\n	     Pete.Patient_att=xPete, Jane.Patient_att=xJane,"
			+ "\n	     BP.Type_att=xBloodPressure, Wt.Type_att=xBodyWeight,"
			+ "\n	     1.f=Pete, 2.f=Pete, 3.f=Jane, 4.f=Jane,"
			+ "\n	     1.g1=1, 2.g1=2, 3.g1=3, 4.g1=1,"
			+ "\n	     1.g2=BP, 2.g2=BP, 3.g2=Wt, 4.g2=Wt;"
			+ "\n} : Sch2"
			+ "\n"
			+ "\n//Input mappings:"
			+ "\n"
			+ "\nF1 = mapping {"
			+ "\n	nodes O->Observation,P->Person, T->ObsType;"
			+ "\n	edges f->f, g->g;"
			+ "\n}	: OverlapSch -> Sch1"
			+ "\n"
			+ "\nF2 = mapping {"
			+ "\n	nodes O->Observation,P->Patient,T->Type;"
			+ "\n	edges f->f, g->g1.g2;"
			+ "\n}	: OverlapSch -> Sch2"
			+ "\n"
			+ "\n//Input homomorphisms:"
			+ "\n"
			+ "\na1 = homomorphism {"
			+ "\n	variables Peter->Peter, BloodPressure->BloodPressure, BodyWeight->BodyWeight;"
			+ "\n}: sigma F1 OvInst -> Inst1"
			+ "\n"
			+ "\na2 = homomorphism {"
			+ "\n	variables Peter->Pete, BloodPressure->BP, BodyWeight->Wt;"
			+ "\n} : sigma F2 OvInst -> Inst2"
			+ "\n"
			+ "\n"
			+ "\n//Get the aliases in the right places."
			+ "\n"
			+ "\nSch1prime = schema {"
			+ "\n	nodes Observation, Person, Gender, ObsType, PAlias;"
			+ "\n	edges f:Observation->Person, h:Person->Gender, g:Observation->ObsType,"
			+ "\n	      Gender_att:Gender->dom, ObsType_att:ObsType->dom,"
			+ "\n	      att:PAlias->dom, p:PAlias->Person;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nU1 = mapping {"
			+ "\n	nodes Observation->Observation, Person->Person, Gender->Gender, ObsType->ObsType, PAlias->Person;"
			+ "\n	edges f -> f, g -> g, h -> h, p -> Person, Gender_att -> Gender_att,"
			+ "\n	      ObsType_att -> ObsType_att, att -> Person_att;"
			+ "\n}	: Sch1prime -> Sch1"
			+ "\n"
			+ "\nSch2prime = schema {"
			+ "\n	nodes Observation, Patient, Method, Type, PAlias;"
			+ "\n	edges f:Observation->Patient, g1:Observation->Method, g2:Method->Type,"
			+ "\n	      Type_att:Type->dom,"
			+ "\n	      att:PAlias->dom, p:PAlias->Patient;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nU2 = mapping {"
			+ "\n	nodes Observation -> Observation, Patient -> Patient, Method -> Method, Type->Type, PAlias -> Patient;"
			+ "\n	edges f->f, g1->g1, g2->g2,"
			+ "\n	      Type_att->Type_att,"
			+ "\n	      att->Patient_att, p -> Patient;"
			+ "\n}	: Sch2prime -> Sch2"
			+ "\n"
			+ "\nInst1prime = delta U1 Inst1"
			+ "\n"
			+ "\nInst2prime = delta U2 Inst2"
			+ "\n"
			+ "\nF1prime = mapping {"
			+ "\n	nodes O->Observation, P->Person, T->ObsType;"
			+ "\n	edges f->f, g->g;"
			+ "\n} : OverlapSch -> Sch1prime"
			+ "\n"
			+ "\nF2prime = mapping {"
			+ "\n	nodes O->Observation, P->Patient, T->Type;"
			+ "\n	edges f->f, g->g1.g2;"
			+ "\n}	: OverlapSch -> Sch2prime"
			+ "\n"
			+ "\n//Form integrator"
			+ "\n"
			+ "\nIntegrator = schema {"
			+ "\n	nodes O,P,PAlias,G,T,M;"
			+ "\n	edges "
			+ "\n		f:O->P, g1:O->M, g2:M->T, h:P->G, "
			+ "\n		G_att:G->dom,"
			+ "\n		T_att:T->dom,"
			+ "\n		p:PAlias->P,"
			+ "\n		att:PAlias->dom;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nG1 = mapping {"
			+ "\n	nodes Observation->O, Person->P, PAlias->PAlias, Gender->G, ObsType->T;"
			+ "\n	edges f->f, g->g1.g2, h->h, p->p, att->att, "
			+ "\n	ObsType_att->T_att, Gender_att->G_att;"
			+ "\n} : Sch1prime -> Integrator"
			+ "\n"
			+ "\nG2 = mapping {"
			+ "\n	nodes Observation->O, Patient->P, PAlias->PAlias, Method->M, Type->T;"
			+ "\n	edges f->f, g1->g1, g2->g2, p->p, att->PAlias.att,"
			+ "\n	Type_att->T_att;"
			+ "\n} : Sch2prime -> Integrator"
			+ "\n"
			+ "\nGover = mapping {"
			+ "\n	nodes O->O, P->P,T->T;"
			+ "\n	edges f->O.f, g->O.g1.g2;"
			+ "\n} "
			+ "\n	: OverlapSch -> Integrator"
			+ "\n"
			+ "\n//sigma F1prime OvInst => delta U1 Inst1  (on Sch1prime)"
			+ "\na1prime = (return sigma delta U1 sigma F1prime OvInst; delta U1 a1)"
			+ "\n"
			+ "\n//sigma F2prime OvInst => delta U2 Inst2 (on Sch2prime)"
			+ "\na2prime = (return sigma delta U2 sigma F2prime OvInst; delta U2 a2)"
			+ "\n"
			+ "\n//push along G1 and G2 to integrator schema"
			+ "\nxxx1 = sigma G1 a1prime"
			+ "\nyyy1 = sigma G2 a2prime"
			+ "\n"
			+ "\n//pushout"
			+ "\nanswer = pushout xxx1 yyy1"
			+ "\n";


}
