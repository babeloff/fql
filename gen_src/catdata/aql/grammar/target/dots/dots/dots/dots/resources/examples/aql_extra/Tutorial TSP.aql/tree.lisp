(file (program (optionsDeclarationSection options (optionsDeclaration (prependEntityOnIds prepend_entity_on_ids = (truthy false)))) (commentDeclarationSection (htmlCommentDeclaration html { (*  "\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> \n <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n <head>\n <link rel=\"stylesheet\" type=\"text/css\" href=\"https://categoricaldata.net/css/simple.css\" />\n <script src=\"https://categoricaldata.net/js/simple.js\"></script>\n </head>\n <body>\n"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n\n# AQL Tutorial\n**Tasks <-> Skills <-> People**\n\n---\n\n"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n## PREFACE - AQL and SQL\n\nThis AQL file interacts with a MySQL database running on <a href=\"http://catinf.com\">catinf.com</a>.  To run the tutorial, it\nis necessary to <a href=\"https://dev.mysql.com/downloads/connector/j/5.1.html\">download the\nMySQL JDBC driver</a> and place it on the java classpath as described in the AQL manual. \n\t"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n## INTRODUCTION\n\nThis file contains a sequence of models intended to illustrate the use of Algebraic Query\nLanguage (AQL) to formalize database concepts in a mathematically verifiable way. Each AQL file \nin this sequence will build on previous ideas, introducing AQL features in the context of\nconceptual models relating skills to tasks and people.\n\nThe following is a brief outline of the sequence of models and what the reader should take away\t\nfrom reviewing each model in the sequence.\n\nThis file introduces a series of AQL constructions and compares those constructions with\nanalogous relational constructions where appropriate. We begin with a set of independent schemas\nand produce a single schema that is an integrated assembly of the three source schemas. The\nfollowing is a table of contents describing the structure of the sequence of AQL constructions\nand concepts developed in this file. The reader should not expect to understand this list at this\npoint. Several passes through the tutorial may be required to fully grasp all that is presented. \nThis file is an executable which when run will generate an execution graphical user interface \nwhere the results can be viewed. Similarly this file will be published to a series of web pages\nwhere the results of each construction will be displayed.\n\n  1. typeside -- User defined kind for customization of data types.\n  2. schema -- Extends the type side to define objects of kind schema.\n  3. category -- Polymorphic abstraction that unifies many AQL concepts and constructions.\n  4. schema as category -- Schemas interpreted through the abstract lens of categories.\n  5. instance -- Extends the schema kind. Instance kinds can be thought of as the data that \n     \"fills\" the schema.\n  6. instance as category -- Instances interpreted through the abstract lens of categories.\n  7. transform -- map from one instance to another of the same schema.\n  8. the category of instances of a schema -- Instance kinds all typed by the same schema\n     related by transforms as arrows.\n  9. instance coproduct -- Universal construction that \"adds\" multiple instances associated \n     with a schema. \n 10. instance coequalizer -- Universal construction that uses a linking instance and a pair\n     of transforms to merge records records within an instance.\n 11. schema mappings, queries and the category of schemas -- Schema mappings define the\n     arrows in the category of schemas. Queries generalize schema mappings and provide \n     functionality similar to SQL queries.\n 12. schema colimits -- A kind that unifies coproducts and coequalizers but in the context of\n     the category of schemas rather than the category of instances of a schema. Generally\n     formalizes a diagram of schemas connected by mappings that can be used to assemble\n     source schemas into a single target schema.\n 13. jdbc pragmas, imports and exports -- Integration of AQL with external data sources and \n     targets. Pragmas are a kind that allows commands to be submitted to a JDBC driver to be \n     executed against an external repository. Imports and exports are features that provide a \n     mechanism for translating between traditional data repositories and AQL semantics.\n 14. Migrating data between schemas -- This is the problem of Extracting - Transforming -\n     Loading or ETL. This is where we tackle problems that involve moving data between \n     schemas and the larger problem of bringing multiple source schemas together and \n     integrating them.\n 15. sigma --| delta --| pi -- The machinery AQL uses to move data around the enterprise. \n     These mappings are the building blocks of the eval construction that moves data through \n     AQL queries.\n\nAs we proceed we will draw analogies to relational constructions that may be more familiar to\npracticing database engineers. We open with a brief review of the essential features of\nrelational algebra as they are related to AQL features.\n\nThe structural element that forms the foundation of relational algebra is the relvar. A relvar is\na mathematical definition that roughly corresponds to the structure of a single table. Commercial\nimplementations of relvars are table definitions based on a set of fixed types provided by the \nrelational database management system (RDBMS) that define the domain over which each column of \nthe table is allowed to vary. Having defined one or more table structures, constraints can be\nadded to further restrict the values over which a particular column may vary. \n\nIn contrast, AQL provides a declarative structure that allows the user to define an algebraic\ndefinition of the type side. In its current implementation AQL defines this algebra by wrapping\na selection of Java types and functions. In this sequence of files we will restrict the type side\nto a string type compatible with a MySQL Varchar. This will allow us to label records in a way\nthat will provide human readable output associated with the sequence of models we produce. This \nwill also allow us to integrate with an external RDBMS by exporting and importing various AQL \nconstructions.\n\nAQL models always begin with a type side declaration. The type side defines a foundation that can \nthen be extended to define schemas.\n"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## Type Sides\n\nType sides are an AQL construction that extends the built in types typically found in RDBMSs and\nprovides the possibility of introducing programming language features that can be used to enhance \nthe power of a database. These features are roughly analogous to stored functions that can be \ninvoked inline within an SQL statement. To illustrate how this capability works we will create a \ntype side that exposes a string type which we label Varchar in anticipation of later integration \nwith an external RDBMS. To this we add the Java string matches method to illustrate how Java \nfunctions can be exposed to the AQL framework. For more details we refer the reader to the \nexamples available by selecting the dropdown in the upper right hand corner of the application. \nSpecifically, the AQL Tutorial example.\n"  *) })) (kindDeclaration (typesideAssignment typeside (typesideId (symbol TypeSide)) = (typesideExp literal { (typesideLiteralSection java_types (typesideJavaTypeSig (typesideTypeId (symbol Varchar)) = (typesideJavaType "java.lang.String")) (typesideJavaTypeSig (typesideTypeId (symbol Bool)) = (typesideJavaType "java.lang.Boolean")) java_constants (typesideJavaConstantSig (typesideConstantId Varchar) = (typesideJavaConstantValue "return input[0]")) (typesideJavaConstantSig (typesideConstantId Bool) = (typesideJavaConstantValue "return java.lang.Boolean.parseBoolean(input[0])")) java_functions (typesideJavaFunctionSig (typesideFnName (symbol Matches)) : (typesideFnLocal (symbol Varchar)) , (typesideFnLocal (symbol Varchar)) -> (typesideFnTarget (symbol Bool)) = (typesideJavaStatement "return input[0].matches(input[1])")) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## SCHEMAS\n\nAs mentioned above the schema is declared as an extension of the type side. Notice that in\ncontrast with relational algebra there is no notion of an entity or relvar in isolation. The\nclosest analog to a relvar in AQL is a schema with a single entity. With that in mind we proceed\nby creating a pair of schemas, each with a single entity, followed by the schema with a pair of\nentities connected by a foreign key.\n\nThe first schema we create is minimal in that it contains a single entity Task with a single\nattribute that allows us to label a task. AQL contains a variety of constructions that build on \non previously defined constructions. Following the programming language literature we will refer \nto such constructions as kinds. In AQL a kind is either a typeside, schema, instance, (schema) \nmapping, (instance) transform, query, graph, pragma, schema\_colimit, or constraints.\n\nBy convention we prefix the schema name with the letter \"s\" to remind the reader when that name \nis encountered in the construction of a dependent kind that the object is of kind schema. \n\nBy clicking on the run button AQL will construct a runtime viewing window that has a list of each\nof the constructions created in this model in a pane on the left hand side of the window. A view\nof each construction is available by clicking on the construction of interest in the left hand\npane.\n\nSimilarly this editor has a pane on the right hand side containing an outline of the\nconstructions contained in this file. One can navigate to a construction by clicking on that\nconstruction in the outline.\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sT)) = (schemaExp literal : (typesideKind (typesideRef (symbol TypeSide))) { (schemaLiteralSection entities (schemaEntityId (symbol Task)) attributes (schemaAttributeSig (schemaAttributeId (symbol TName)) : (schemaEntityId (symbol Task)) -> (typesideTypeId (symbol Varchar))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nNow we create a slightly more interesting schema. This schema still consists of only one entity,\nbut that entity now has a pair of attributes.\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sSnT)) = (schemaExp literal : (typesideKind (typesideRef (symbol TypeSide))) { (schemaLiteralSection entities (schemaEntityId (symbol SkillNeededForTask)) attributes (schemaAttributeSig (schemaAttributeId (symbol skill)) : (schemaEntityId (symbol SkillNeededForTask)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol task)) : (schemaEntityId (symbol SkillNeededForTask)) -> (typesideTypeId (symbol Varchar))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## CATEGORIES INTRODUCED\n**Schemas as Categories**\n\nThe third schema we introduce has two entities, `Skill` and `SkillClass` that define a simple two\nlevel taxonomy for skills. This brings into play additional sections as part of the declarative\nstructure of a schema. First the `foreign_keys` section. In AQL, schemas as first class objects come\nequipped with all of the machinery for defining a schema as a kind. This includes declaration of\ndependencies between entities. These dependencies are given the name foreign key so as to be\nconsistent with relational nomenclature.\n\nFinally we have a third section that has no analog in SQL systems, the observation_equations section.\nTo understand this section we must take time for a brief digression to introduce the abstract \nnotion of a category. \n\nAQL is motivated by a branch of mathematics known as category theory. The reader who is interested \nin a systematic development of category theory should refer to any one of a number of excellent\nintroductions. Here are several such references:\n\n  * _Category Theory_ by Steve Awodey\n  * _Category Theory for Computing Science_ by Michael Barr and Charles Wells\n  * _Category Theory for the Sciences_ By David Spivak\n  * _Conceptual Mathematics: A first introduction to categories_ by F. William Lawvere and Stephen\n    H. Schanuel.\n\nWe begin with an intuitive description of categories and identify specific concrete examples as \nthey relate to AQL. This is followed by a formal description of a category.\n\nA category consists of a set of objects connected by arrows. As such, a category is related to a\ndirected graph where the objects are nodes and arrows are edges with direction indicated by their\nassociated arrow. In addition to the properties of a directed graph each object of a category is\nrequired to have a distinguished arrow that identifies that object and whose source and target are\nequal to the object it identifies.\n\nLet's consider the three schemas we have so far constructed, but with an empty type side (i.e. no\nattributes). Each such schema could be viewed as an abstract category where the set of objects is\nthe set of entities and its arrows are foreign keys. Hence schemas are the first example of an AQL \nconstruction that can be interpreted as a category.\n\nWith this in mind `sT` and `sSnT` are both one object categories. By virtue of the fact that the set \nof identity arrows and the set of objects are essentially the same set (technically isomorphic\nto each other) we can unambiguously refer to each identity arrow using the same label as its\ncorresponding entity. Similarly `sS` (again neglecting attributes) is a two object category with\none non-identity arrow, the foreign key `fk_HasClass`. This category is sometimes called the \"arrow\ncategory\". In future examples we will see that more generally schemas with empty type sides are\nnot strictly speaking categories, but rather presentations of categories. This means they have\nall the information necessary to generate a category through a process known as saturation.\n\nAbstract categories are by design devoid of attachments to any specific context. In order to\nleverage the context free nature of category theory we need a mechanism by which we can anchor\na category into a computational environment. Functional programming languages such as Haskell\nprovide one strategy for doing this. AQL provides another strategy that is motivated by the\ncapabilities of modern database management systems, so AQL extends the basic notion of an\nabstract category with a type side. We will rely on the above intuitive motivation and will not\nformally develop this idea here. The interested reader is referred to the research paper upon \nwhich the AQL implementation is based:\n\n[https://arxiv.org/abs/1602.03501](https://arxiv.org/abs/1602.03501)\n\nThere is an additional feature of categories that is critical to this discussion and that lies\nat the heart of the expressive power of category theory. This the notion of a path. A category\nby definition contains all paths that can be generated by composing arrows head to tail. This\nprocess of generating all paths implied by arrow composition is the aforementioned saturation.\n\nThe order in which one chooses to compose arrows has no effect on the result so AQL provides a\nconvenient syntax for indicating a path using the dot notation (elaborated below). Having added\nadditional arrows for each path we now have the ability to declare two paths that begin and end \non the same object to be equal and so the declarative structure of a category includes equations.\n\nPath equations can be used to complete an intuitive explanation of the properties of identity \narrows. Any path that includes an identity arrow is equal to the path obtained when that identity \narrow is omitted. Considering arrow composition as analogous to addition we can think of identity\narrows as analogous to zero, but rather than having one zero we have one for each object in the\ncategory. Category theorists make this analogy by saying that identity arrows are paths of length\nzero. To further strengthen this analogy it can be shown that the counting numbers under the\nbinary operation of addition define a one object category. Each arrow of the category is a\ncounting number. Zero is the identity arrow. Addition is arrow composition.\n\n\n**Category Definition**\n\nHere is a formal definition of a category following the presentation in Category Theory for \nComputing Sciences chapter 2.\n\nWe begin with a formal definition of a directed graph:\nA directed graph `C` is a pair of functions source: `C_1` -> `C_0` and target: `C_1` -> `C_0`. The elements\nof `C_0` we call nodes/objects and the elements of `C_1` we call edges/arrows. An arrow path of\nlength `n` in `C` is a sequence of arrows arranged head to tail as follows:\n\n         f_n    f_n-1    ...     f_2     f_1\n      . ----> . ----> .  ...  . ----> . ----> . \n\n"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nFor any adjacent pair of arrows in such a path we must have `target(f_k)` = `source(f_k-1)`. Such\nadjacent pairs we call composable pairs. In such a graph one can define sets of paths of length `n`\nwhich we designate `C_n`.\n\nThe definition of a category extends the definition of a directed graph:\nA category is a graph `C` together with two functions `c: C_2` -> `C_1` and `u: C_0 -> C_1` with\nproperties `C-1` through `C-4` below. The function `c` we call composition, and if `(f, g)` is a\ncomposable pair, `c(f,g)` is written `f.g` and is called the composite of `f` followed by `g`. \nIf `A` is an object of `C`, `u(A)` is denoted `id_A` or just `A`, which is called the identity of\nthe object `A`.\n\n  * C-1 The source of `f.g` is the source of `f` and the target of `f.g` is the target of `g`.\n  * C-2 `(f.g).h = f.(g.h)` whenever either is defined.\n  * C-3 The source and target of `id_A` are both `A`.\n  * C-4 If `f: A -> B`, `id_A.f = f.id_B = f` (alternatively `A.f = f.B = f`).\n\nWe now introduce the fourth section in the schema declaration below, the `observation_equations` \nsection. The `observation_equations` section is an example of a path equation. Notice that \n`SCNameOnSkill` is an arrow from `Skill` to `Varchar`. As such it is a path of length one. Similarly\nthere is a path from `Skill` to `Varchar` that is a path of length two obtained by composing the \nforeign key arrow `fk_HasClass` with the attribute arrow `SCName`. The observation equation is a \ndeclaration that those two paths are equal.\n\nThe practical significance of this is far reaching, but in this case it provides us with a\nmechanism to denormalize our schema while guaranteeing that no inconsistencies will be allowed. \n\nMuch of the power of category theory comes from its polymorphic nature. Many different contexts\ncan be interpreted through the abstract lens of category theory. We will see in the coming\ndiscussion that many of the kinds supported by AQL can be interpreted using category theory.\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sS)) = (schemaExp literal : (typesideKind (typesideRef (symbol TypeSide))) { (schemaLiteralSection entities (schemaEntityId (symbol Skill)) (schemaEntityId (symbol SkillClass)) foreign_keys (schemaForeignSig (schemaForeignId (symbol fk_HasClass)) : (schemaEntityId (symbol Skill)) -> (schemaEntityId (symbol SkillClass))) attributes (schemaAttributeSig (schemaAttributeId (symbol SName)) : (schemaEntityId (symbol Skill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol SCNameOnSkl)) : (schemaEntityId (symbol Skill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol SCName)) : (schemaEntityId (symbol SkillClass)) -> (typesideTypeId (symbol Varchar))) observation_equations (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol SCNameOnSkl)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_HasClass)))) . (schemaArrowId (schemaEntityId (symbol SCName))))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## INSTANCES\n\nAs schemas extend the type side so instances extend schemas. An AQL instance can be\nconceptualized as the data that \"fills\" a schema. Minimally, an instance consists of a set of \ngenerators for each entity in the schema. A generator is a string used by AQL that serves to\nidentify a particular record in an entity. The user can optionally create equational definitions \nwhich associate the generator of one entity with that of another or a generator with an attribute \nvalue. In the absence of such an association AQL will create what is called a Skolem term. Skolem \nterms are essential for creating a database instance that can be formally defined and verified as \nconsistent. Skolem terms at a type are referred to as a labeled null. Skolem terms at an entity \nare referred to as a meaningless identifier. Notice that labeled nulls are very different than \nnulls in currently available RDBMSs.\n\nEvery null in AQL is typed by its associated generator and the path to the location in a schema \nwhere a value is missing. For example, in the instance definition below we failed to provide any \ngenerators for skill classes and so AQL created a Skolem term for each unknown skill class \nbeginning with a skill generator followed by the foreign key path. So for the Math skill there \nis an unknown generator `s0.fk_HasClass` whose unknown name is `s0.fk_HasClass.SCName`.\n\nThe following is a representative instance of skills. The way to think about this representative\nis that it is one member of a universe of possible instances all of which are derived from the\nsame schema type `sS`. To summarize, so far we have introduced the idea that AQL constructions are \norganized around the kind hierarchy:\n\ntypeside <- schema <- instance.\n\nRunning this file and selecting an instance below will display a tabular representation of each\ninstance.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSkl)) = (instanceExp literal : (schemaKind (schemaRef (symbol sS))) { (instanceLiteralSection generators (instanceLiteralGen (instanceGenId (symbol s0)) (instanceGenId (symbol s1)) (instanceGenId (symbol s2)) (instanceGenId (symbol s3)) (instanceGenId (symbol s4)) (instanceGenId (symbol s5)) (instanceGenId (symbol s6)) (instanceGenId (symbol s7)) (instanceGenId (symbol s8)) (instanceGenId (symbol s9)) : (schemaEntityId (symbol Skill))) multi_equations (instanceMultiEquation (instanceEquationId (symbol SName)) -> { (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s0)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CategoryTheory)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s1)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CompSci)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s2)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol DBA)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s3)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Pharma)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s4)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Programming)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s5)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Lecturing)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s6)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol GrantWriting)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s7)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Finance)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s8)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Management)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol s9)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol PaperWriting)))))) }) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nAnalogous to the skills instance above we create a representative instance for tasks.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iTsk)) = (instanceExp literal : (schemaKind (schemaRef (symbol sT))) { (instanceLiteralSection generators (instanceLiteralGen (instanceGenId (symbol t1)) (instanceGenId (symbol t2)) (instanceGenId (symbol t3)) (instanceGenId (symbol t4)) (instanceGenId (symbol t5)) (instanceGenId (symbol t6)) (instanceGenId (symbol t7)) (instanceGenId (symbol t8)) (instanceGenId (symbol t9)) (instanceGenId (symbol t10)) : (schemaEntityId (symbol Task))) multi_equations (instanceMultiEquation (instanceEquationId (symbol TName)) -> { (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t1)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol LaunchCIStartup)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t2)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildAQL)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t3)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteAQLTutorial)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t4)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildPhrmColim)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t5)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildFncColim)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t6)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteCTPaper)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t7)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol TeachCT)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t8)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol TeachCS)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t9)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol RunPhrmIntProject)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol t10)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol RunFncIntProject)))))) }) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nThe definition of an entity with a pair of attributes provides us with the ability to create an\ninstance that associates each such pair with the same generator. Here we illustrate this idea\nwith such a representative instance.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSnT)) = (instanceExp literal : (schemaKind (schemaRef (symbol sSnT))) { (instanceLiteralSection generators (instanceLiteralGen (instanceGenId (symbol st1)) (instanceGenId (symbol st2)) (instanceGenId (symbol st3)) (instanceGenId (symbol st4)) (instanceGenId (symbol st5)) (instanceGenId (symbol st6)) (instanceGenId (symbol st7)) (instanceGenId (symbol st8)) (instanceGenId (symbol st9)) (instanceGenId (symbol st10)) (instanceGenId (symbol st11)) (instanceGenId (symbol st12)) (instanceGenId (symbol st13)) (instanceGenId (symbol st14)) (instanceGenId (symbol st15)) (instanceGenId (symbol st16)) (instanceGenId (symbol st17)) (instanceGenId (symbol st18)) (instanceGenId (symbol st19)) (instanceGenId (symbol st20)) (instanceGenId (symbol st21)) (instanceGenId (symbol st22)) (instanceGenId (symbol st23)) (instanceGenId (symbol st24)) : (schemaEntityId (symbol SkillNeededForTask))) multi_equations (instanceMultiEquation (instanceEquationId (symbol skill)) -> { (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st1)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CompSci)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st2)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Programming)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st3)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol GrantWriting)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st4)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol PaperWriting)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st5)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CompSci)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st6)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Programming)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st7)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Management)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st8)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Programming)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st9)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Lecturing)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st10)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol PaperWriting)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st11)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Pharma)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st12)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Programming)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st13)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Finance)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st14)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Programming)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st15)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CategoryTheory)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st16)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol PaperWriting)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st17)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CategoryTheory)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st18)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Lecturing)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st19)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Pharma)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st20)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Management)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st21)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Finance)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st22)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Management)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st23)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol CompSci)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st24)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Lecturing)))))) }) (instanceMultiEquation (instanceEquationId (symbol task)) -> { (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st1)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol LaunchCIStartup)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st2)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol LaunchCIStartup)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st3)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol LaunchCIStartup)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st4)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol LaunchCIStartup)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st5)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildAQL)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st6)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildAQL)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st7)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildAQL)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st8)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteAQLTutorial)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st9)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteAQLTutorial)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st10)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteAQLTutorial)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st11)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildPhrmColim)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st12)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildPhrmColim)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st13)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildFncColim)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st14)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol BuildFncColim)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st15)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteCTPaper)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st16)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol WriteCTPaper)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st17)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol TeachCT)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st18)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol TeachCT)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st19)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol RunPhrmIntProject)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st20)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol RunPhrmIntProject)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st21)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol RunFncIntProject)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st22)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol RunFncIntProject)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st23)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol TeachCS)))))) , (instanceMultiBind (instancePath (instanceArrowId (schemaEntityId (symbol st24)))) (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol TeachCS)))))) }) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n**Instance Categories**\n\nLike schemas, instances can also be viewed as categories. To make this clearer consider these\nalternative syntaxes for declaring an instance using the equations keyword. The following are\nboth equivalent to the `iSkl` declaration above:\n\n    instance iSkl = literal : sS {\n        generators\n            s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill\n        equations\n          s0.SName = CategoryTheory    s1.SName = CompSci        s2.SName = DBA\n          s3.SName = Pharma            s4.SName = Programming    s5.SName = Lecturing\n          s6.SName = GrantWriting      s7.SName = Finance        s8.SName = Management\n          s9.SName = PaperWriting\n    }\n    instance iSkl = literal : sS {\n        generators\n            s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill\n        equations\n          SName(s0) = CategoryTheory    SName(s1) = CompSci        SName(s2) = DBA\n          SName(s3) = Pharma            SName(s4) = Programming    SName(s5) = Lecturing\n          SName(s6) = GrantWriting      SName(s7) = Finance        SName(s8) = Management\n          SName(s9) = PaperWriting\n    }\n\nThe objects of an instance category are the generators plus the Skolem terms produced by those\ngenerators. The arrows are either a foreign key evaluated at a generator/Skolem term or an \nattribute evaluated at a generator/Skolem term. Like a schema the literal declaration of an \ninstance is a presentation of an instance category. As you will see when you run an AQL model \nwith a literal instance declaration AQL will fill Skolem terms as implied by the schema and the \nprovided generators.\n\nNotice these equations declare instance arrows in a way that is closely analogous to an RDF \ntriple. The subject of a triple is a generator/Skolem term, the object of a triple is either a \nliteral (value on the type side) or another generator/Skolem term and the predicate is the type \non the arrow as determined by the underlying schema. As such AQL instances are closely related to \ngraph databases although they are very strongly typed by their underlying schema.\n\nIn order to extend the instance `iSkl` to include classes we need to decide how we want to\npartition the skills we have into broad equivalence classes (we list the generators for \nconvenience):\n\n  * Class 1: CategoryTheory, CompSci, DBA, Programming (s0, s1, s2, s4)\n  * Class 2: Pharma, Lecturing, Finance, Management (s3, s5, s7, s8)\n  * Class 3: GrantWriting, PaperWriting (s6, s9)\n  \nAQL provides the ability to extend any construction by importing a construction already in place,\nso using the path dot notation we extend the `iSkl` instance as follows:\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSklExt)) = (instanceExp literal : (schemaKind (schemaRef (symbol sS))) { (instanceLiteralSection imports (instanceRef (symbol iSkl)) equations (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s0)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s1)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s0)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s2)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s0)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s4)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s3)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s5)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s3)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s7)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s3)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s8)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s6)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s9)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nNotice that each of the paths in the equations above have a direct correspondence with a Skolem \nterm. Hence, in contrast with traditional database NULL values, Skolem terms can be manipulated \nin the same way any other value can be manipulated. If you compare `iSkl` and `iSklExt` in the \nruntime GUI you will note that the number of Skolem terms has decreased from ten (one for each \nskill) to three (one for each equivalence class).\n"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n**The Category of Instances of a Schema**\n\nNow lets see if we can give these skill class labeled nulls labels. To do this we have to\nintroduce another example of a category, the universe of possible instances that are all based on \na particular schema. For example all instances of `sS` define a category. The objects are instances \nof `sS` and we already have two examples, `iSkl` and `iSklExt`. The arrows are transforms from one\ninstance of `sS` to another instance of `sS`. A transform is an instance map that preserves the \nstructure of the instance. We will return to transforms in a moment, but for now lets create a\nthird instance with labels for our three skill classes.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSklCls)) = (instanceExp literal : (schemaKind (schemaRef (symbol sS))) { (instanceLiteralSection generators (instanceLiteralGen (instanceGenId (symbol sc0)) (instanceGenId (symbol sc1)) (instanceGenId (symbol sc2)) : (schemaEntityId (symbol SkillClass))) equations (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol sc0)))) . (instanceArrowId (schemaEntityId (symbol SCName)))) = (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Cognitive)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol sc1)))) . (instanceArrowId (schemaEntityId (symbol SCName)))) = (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Social)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol sc2)))) . (instanceArrowId (schemaEntityId (symbol SCName)))) = (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol Psychomotor)))))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nAn important idea in category theory is the notion of a universal construction. We now introduce\nthe AQL implementation of such a construction. The idea is that given a particular structure\ndefined by a diagram one can consider all possible examples of that structure in a particular\ncategory. By that we mean all examples that have the same shape as the diagram in question. Let's\nconsider a diagram called a cospan. It has this shape: `t1: A --> X <-- B :t2`. As we were \ncurrently talking about the category of instances of the schema `sS`, the objects `A`, `X`, and `B`\nare instances and the two arrows are transforms. A cospan in this category is any valid collection\nof three instances of `sS` that are related to one another via a pair of transforms.\n\nGiven a choice of instances say `iSklExt` and `iSklCls` we can consider all possible ways of \ncombining `iSklExt` and `iSklCls` with a pair of transforms to get a third instance `X`. The\nuniversal way of combining `iSklExt` and `iSklCls` to get an `X` is the one to which all others can\nbe related in a unique way. That is to say, for any `X` and any pair of valid transforms `t1` and\n`t2` the universal cospan `iA: iSklExt --> iSklCP <-- iSklCls :iB` is the cospan such that there\nexists a unique transform:\n\n    t(t1,t2): iSklCP --> X such that\n    iA.t(t1,t2) = t1 and\n    iB.t(t1,t2) = t2\n\nfor any `X` and any pair of transforms `(t1, t2)`. What this means is that the pair of arrows `t1`\nand `t2` can be replaced with the single arrow `t(t1,t2)`.\n\nConceptually this construction is a generalization of the SQL \"UNION ALL\" statement. It is a \ngeneralization in that it applies to a pair of instances of a schema rather than a pair of \nrelations of a relvar. This construction is known as a coproduct. We say that `iA` and `iB` are \ninjections of the instances `iSklExt` and `iSklCls` into the coproduct. You can see the effect of\nthis construction by running this file and selecting `iSklCP` in the viewer. Notice the result is\nan instance `sS` that is the disjoint union of the records of `iSklExt` and `iSklCls` that has\nrespected the foreign key `fk_HasClass`.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSklCP)) = (instanceExp union (instanceKind (instanceRef (symbol iSklExt))) + (instanceKind (instanceRef (symbol iSklCls))) : (schemaKind (schemaRef (symbol sS)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nNow that we have all of the desired records in the same instance we want to identify the\ngenerators that came from `iSklCls` with the Skolem terms that came from the `iSklExt` instance. To \nachieve this result we would like to declare that each of the Skolem terms from `iSklExt` should be \nmerged with the appropriate generator coming from `iSklCls`. Recall we have already done this by \nimporting an existing instance into a new instance and adding equations. Here is the solution\nusing that approach.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSklSklCls1)) = (instanceExp literal : (schemaKind (schemaRef (symbol sS))) { (instanceLiteralSection imports (instanceRef (symbol iSklCP)) equations (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s0)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol sc0)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s3)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol sc1)))))) (instanceEquation (instancePath (instancePath (instanceArrowId (schemaEntityId (symbol s6)))) . (instanceArrowId (schemaEntityId (symbol fk_HasClass)))) = (instanceEquationValue (instancePath (instanceArrowId (schemaEntityId (symbol sc2)))))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nThere is an alternative construction that is universal. First we create an instance `iSLnk` with a \ngenerator for each of the skill classes. We then create two instance transforms, the first \nmapping each link generator to a `iSklExt` Skolem term and the second mapping each link generator \nto our `iSklCls` generators. The new universal construction is known as a coequalizer. An instance \ncoequalizer uses a pair of transforms to define collections of records that are identified as \nequal. This approach has the advantage that linking instances and transforms can be imported from \nan external database using SQL queries.\n\nThis construction is a generalization of the notion of partitioning a set into equivalence\nclasses. Later we will see how these constructions can be applied to other categories in AQL.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSLnk)) = (instanceExp literal : (schemaKind (schemaRef (symbol sS))) { (instanceLiteralSection generators (instanceLiteralGen (instanceGenId (symbol scLnk0)) (instanceGenId (symbol scLnk1)) (instanceGenId (symbol scLnk2)) : (schemaEntityId (symbol SkillClass))) allOptions) }))) (kindDeclaration (transformAssignment transform (transformId (symbol tS1)) = (transformExp literal : (instanceKind (instanceRef (symbol iSLnk))) -> (instanceRef (symbol iSklCP)) { (transformLiteralSection generators (transformGen (symbol scLnk0) -> (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol s0)))) . (schemaArrowId (schemaEntityId (symbol fk_HasClass))))) (transformGen (symbol scLnk1) -> (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol s3)))) . (schemaArrowId (schemaEntityId (symbol fk_HasClass))))) (transformGen (symbol scLnk2) -> (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol s6)))) . (schemaArrowId (schemaEntityId (symbol fk_HasClass))))) allOptions) }))) (kindDeclaration (transformAssignment transform (transformId (symbol tS2)) = (transformExp literal : (instanceKind (instanceRef (symbol iSLnk))) -> (instanceRef (symbol iSklCP)) { (transformLiteralSection generators (transformGen (symbol scLnk0) -> (schemaPath (schemaArrowId (schemaEntityId (symbol sc0))))) (transformGen (symbol scLnk1) -> (schemaPath (schemaArrowId (schemaEntityId (symbol sc1))))) (transformGen (symbol scLnk2) -> (schemaPath (schemaArrowId (schemaEntityId (symbol sc2))))) allOptions) }))) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSklSklCls2)) = (instanceExp coequalize (transformKind (transformRef (symbol tS1))) (transformKind (transformRef (symbol tS2)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nNotice we can summarize the sequence of constructions above as follows:\n \n    s0.fk_HasClass <- scLnk0 -> sc0\n    s3.fk_HasClass <- scLnk1 -> sc1\n    s6.fk_HasClass <- scLnk2 -> sc2,\n\nwhich in turn is structurally equivalent to the equations in `iSklSklCls1`.\n"  *) })) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## AQL QUERIES\n**And the Category of Schemas**\n\nThe next example of a category we need is the category of schemas. Since a schema can be viewed\nas a presentation of a category the category of schemas is closely related to the category of\ncategories. The objects of the category of schemas are of course schemas and the arrows are\nreferred to in AQL as mappings. There is a syntax for the literal declaration of a mapping that \nis provided by AQL, but we will not elaborate on that syntax as you will see that most\napplications of mappings are either implicit in other constructions or generalizations to\nmappings as in the case of queries which we introduce in this section.\n\nConceptually mappings preserve the structure of a schema, that is, they map entities and foreign\nkeys/attributes in a consistent way. For the interested reader the name given mappings in the\nmathematical literature is functor, as a functor can be viewed as a generalized function. Queries\nfurther generalize mappings in the same way that a cospan `A -> B <- C` generalizes a single arrow \n`A -> C`.\n\nAQL queries can be used to extract some part of a schema instance as well as to calculate derived \nresults. This construction is the query kind. We illustrate in our first example a simple form of \nan AQL query that is very similar to an SQL query.\n\n  * The from clause: like SQL lists the entities from which the query is constructed. AQL differs\n    in that each entity must be provided with a variable that serves as a representative generator\n    for that entity. This is syntactically similar to an SQL alias though not optional.\n  * The where clause: Again similar to the where clause in SQL in that it provides a means for\n    filtering records and joining entities.\n  * The attributes clause: The attributes clause is analogous to the select clause in SQL and defines what\n    the query output is.\n  \nWe make use of the Java string method \"matches\" we have exposed through the type side. This\nmethod allows us to pass a regular expression that can be used as a filter for any skill name \nending in the string \"Writing\".\n"  *) })) (kindDeclaration (queryAssignment query (queryId (symbol qWrtngSklS)) = (queryExp simple : (schemaKind (schemaRef (symbol sS))) { (querySimpleSection (queryClauseExpr from (queryClauseFrom (queryGen (symbol s)) : (schemaEntityId (symbol Skill))) where (queryClauseWhere (queryPath (queryGen (symbol Matches)) ( (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SName)))) , (queryPath (queryLiteralValue ".*Writing")) )) = (queryPath (queryLiteralValue true))) attributes (queryPathMapping (queryGen (symbol Skill_Name)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SName))))) (queryPathMapping (queryGen (symbol Skill_Class_Name)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SCNameOnSkl))))) allOptions)) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nBy virtue of AQL's ability to define multiple instances associated with a schema, to execute a\nquery it must be evaluated on an instance to define a new instance. When queries are of the\nsimple type as in this example the schema is implicitly defined as having a single entity with\nattributes as listed in the return clause.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iWrtngSklS)) = (instanceExp eval (queryKind (queryRef (symbol qWrtngSklS))) (instanceKind (instanceRef (symbol iSkl)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nTo illustrate the more complete query syntax we must explicitly declare a target schema. Below\nwe rewrite `qWrtngSklS` to illustrate the more complete syntax. First we define the target schema\nwith a single entity `tSkill` and the two attributes listed in the return clause above:\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sSkl)) = (schemaExp literal : (typesideKind (typesideRef (symbol TypeSide))) { (schemaLiteralSection entities (schemaEntityId (symbol tSkill)) attributes (schemaAttributeSig (schemaAttributeId (symbol Skill_Name)) : (schemaEntityId (symbol tSkill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol Skill_Class_Name)) : (schemaEntityId (symbol tSkill)) -> (typesideTypeId (symbol Varchar))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nNext we create a query whose kind is an arrow from the source schema `sS` to the target schema\n`sSkl`. This complete syntax requires a query sub-section for each entity in the target schema. \nAdditionally the complete syntax requires an assignment for all attributes defined in the target \nschema. The query `qWrtngSklC` is functionally equivalent to `qWrtngSklS`. If you run this model you \nwill notice that the instance `iWrtngSklS` is identical to the instance `iWrtngSklC`.\n"  *) })) (kindDeclaration (queryAssignment query (queryId (symbol qWrtngSklC)) = (queryExp literal : (schemaKind (schemaRef (symbol sS))) -> (schemaRef (symbol sSkl)) { (queryLiteralSection entity (queryEntityExpr (schemaEntityId (symbol tSkill)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol s)) : (schemaEntityId (symbol Skill))) where (queryClauseWhere (queryPath (queryGen (symbol Matches)) ( (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SName)))) , (queryPath (queryLiteralValue ".*Writing")) )) = (queryPath (queryLiteralValue true))) attributes (queryPathMapping (queryGen (symbol Skill_Name)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SName))))) (queryPathMapping (queryGen (symbol Skill_Class_Name)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SCNameOnSkl))))) allOptions) }) allOptions) }))) (kindDeclaration (instanceAssignment instance (instanceId (symbol iWrtngSklC)) = (instanceExp eval (queryKind (queryRef (symbol qWrtngSklC))) (instanceKind (instanceRef (symbol iSkl)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nQueries as structure preserving maps of schemas have the capability of mapping not only entities\nbut also foreign keys. In this example we will build a query that has as its source and target \nschemas `sS` but is not an identity. This example filters for those skills that are classified as \nsocial skills.\n\nGiven its novel nature, let's take a moment to elaborate on the syntax of the `foreign_keys` \nsection. We have duplicated the declaration of the foreign key we are constructing in a comment as \nreference. The `fk_HasClass` foreign key enforces a functional dependency between the generators of\nthe entity Skill and the generators of of the entity `SkillClass`. In the entities section we have\ngenerator variables sc for the `SkillClass` entity and `s` for the `Skill` entity. These are variables \nthat vary over the generators and Skolem terms created by the saturation process. The task at \nhand is to use those variables and the source foreign key to construct a functional dependency in \nthe target schema. We do this by taking a `SkillClass` generator and assigning it as the return \nvalue of the target foreign key `fk_HasClass`. Which generator do we assign? The one we get by \ntaking a skill generator and following it to its skill class. Notice that this is opposite to the \ndirection of the arrow associated with the `fk_SkillClass` functional dependency.\n\nNote: If you removed the where clause from each entity sub-section you would have the identity \nmapping.\n"  *) })) (kindDeclaration (queryAssignment query (queryId (symbol qScl)) = (queryExp literal : (schemaKind (schemaRef (symbol sS))) -> (schemaRef (symbol sS)) { (queryLiteralSection entity (queryEntityExpr (schemaEntityId (symbol SkillClass)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol sc)) : (schemaEntityId (symbol SkillClass))) where (queryClauseWhere (queryPath (queryGen (symbol sc)) . (schemaArrowId (schemaEntityId (symbol SCName)))) = (queryPath (typesideConstantId Social))) attributes (queryPathMapping (queryGen (symbol SCName)) -> (queryPath (queryGen (symbol sc)) . (schemaArrowId (schemaEntityId (symbol SCName))))) allOptions) }) entity (queryEntityExpr (schemaEntityId (symbol Skill)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol s)) : (schemaEntityId (symbol Skill))) where (queryClauseWhere (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol fk_HasClass))) . (schemaArrowId (schemaEntityId (symbol SCName)))) = (queryPath (typesideConstantId Social))) attributes (queryPathMapping (queryGen (symbol SName)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SName))))) (queryPathMapping (queryGen (symbol SCNameOnSkl)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol SCNameOnSkl))))) foreign_keys (queryForeignSig (schemaForeignId (symbol fk_HasClass)) -> { (queryPathMapping (queryGen (symbol sc)) -> (queryPath (queryGen (symbol s)) . (schemaArrowId (schemaEntityId (symbol fk_HasClass))))) }) allOptions) }) allOptions) }))) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSclSkl)) = (instanceExp eval (queryKind (queryRef (symbol qScl))) (instanceKind (instanceRef (symbol iSklSklCls1)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## SCHEMA COLIMIT\n\nNext we introduce an AQL feature that allows us to assemble multiple source schemas into a single\ntarget schema. This construction is called a schema colimit by virtue of its mathematical origins\nin category theory. Generally colimits are a class of universal constructions that take a diagram\nof objects connected by arrows and assemble those objects in a way consistent with the diagram.\nWe have already seen an example of a colimit in the instance coproduct. Now we apply AQL's\nimplementation of that same universal construction to the category of schemas. When applied to\nschemas the coproduct results in a construction analogous to what is sometimes called \"landing\"\ntables from multiple source schemas into a single schema where data transforms can be \nconveniently developed.\n\nIn this particular case we \"land\" the three schemas `sT`, `sS`, `sSnT` using the single structure\n`S_T_SnT_SumAuto` whose kind is `schema_colimit`. We will develop the connection of a schema \ncoproduct with a instance coproduct in a moment, but for now examine the automatically generated \ncoproduct in the runtime viewer.\n"  *) })) (kindDeclaration (schemaColimitAssignment schema_colimit (schemaColimitId (symbol S_T_SnT_SumAuto)) = (schemaColimitExp coproduct (schemaRef (symbol sT)) + (schemaRef (symbol sS)) + (schemaRef (symbol sSnT)) : (typesideRef (symbol TypeSide))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nThe automatically generated schema colimit prefixes each object within the target schema with the\nlabel associated with the source schema from which that object originated. With the modify\ncommand we have the option of providing whatever names we choose independent of the names\nassociated with the source schemas from which they originated. In this case we designate each\nentity with the prefix `l` to indicate that it was landed using the coproduct operation.\n"  *) })) (kindDeclaration (schemaColimitAssignment schema_colimit (schemaColimitId (symbol S_T_SnT_Sum)) = (schemaColimitExp modify (schemaColimitRef (symbol S_T_SnT_SumAuto)) { (schemaColimitModifySection rename entities (scEntityPath (schemaTermId (schemaEntityId (symbol sS_Skill)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol lSkill)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sS_SkillClass)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol lSkillClass)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sT_Task)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol lTask)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSnT_SkillNeededForTask)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol lSkillNeededForTask)))) rename foreign_keys (scFkPath (schemaRef (symbol lSkill)) . (schemaTermId (schemaEntityId (symbol sS_Skill_fk_HasClass)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol lfk_HasClass)))) rename attributes (scAttrPath (schemaRef (symbol lSkill)) . (schemaTermId (schemaEntityId (symbol sS_Skill_SName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol lSName)))) (scAttrPath (schemaRef (symbol lSkill)) . (schemaTermId (schemaEntityId (symbol sS_Skill_SCNameOnSkl)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol lSCNameOnSkl)))) (scAttrPath (schemaRef (symbol lSkillClass)) . (schemaTermId (schemaEntityId (symbol sS_SkillClass_SCName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol lSCName)))) (scAttrPath (schemaRef (symbol lTask)) . (schemaTermId (schemaEntityId (symbol sT_Task_TName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol lTName)))) (scAttrPath (schemaRef (symbol lSkillNeededForTask)) . (schemaTermId (schemaEntityId (symbol sSnT_SkillNeededForTask_skill)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol lskill)))) (scAttrPath (schemaRef (symbol lSkillNeededForTask)) . (schemaTermId (schemaEntityId (symbol sSnT_SkillNeededForTask_task)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ltask))))) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n**Schema Colimit Diagram**\n\nRecalling our earlier description of the instance coproduct which was a cospan of instances, a \nschema coproduct is a cospan of schemas and as such includes a schema and a pair of structure\npreserving maps of schemas.\n\nWith the sequence of constructions below we reveal the inner structure of the particular schema\ncolimit we have created. In this case there are three source objects and three associated arrows\nrather than two as was the case with the instance coproduct. We would call this a wide cospan which\nextends the concept of a span to include any number of source objects. Specifically, for this\nschema colimit we have a target schema and a schema mapping which lands (injects) each source schema\ninto that landing (target) schema. This means that a schema colimit can be thought of as a diagram\nof schemas and schema mappings. In this particular case, using the labels assigned below, we have\nthe following diagram:\n\n                     mSToS_T_SnT_Sum        mTToS_T_Snt_Sum\n                     sS --------> sS_T_Snt_Sum <-------- sT\n                                       /\\\n                     mSnTToS_T_SnT_Sum |\n                                       |\n                                     sSnT\n\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sS_T_SnT_Sum)) = (schemaExp getSchema (schemaColimitRef (symbol S_T_SnT_Sum))))) (kindDeclaration (mappingAssignment mapping (mappingId (symbol mSToS_T_SnT_Sum)) = (mappingExp getMapping (schemaColimitRef (symbol S_T_SnT_Sum)) (schemaRef (symbol sS))))) (kindDeclaration (mappingAssignment mapping (mappingId (symbol mTToS_T_Snt_Sum)) = (mappingExp getMapping (schemaColimitRef (symbol S_T_SnT_Sum)) (schemaRef (symbol sT))))) (kindDeclaration (mappingAssignment mapping (mappingId (symbol mSnTToS_T_SnT_Sum)) = (mappingExp getMapping (schemaColimitRef (symbol S_T_SnT_Sum)) (schemaRef (symbol sSnT))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## Migrating Data Between Schemas\n**Sigma --| Delta --| Pi**\n\nLet's recap where we are. We have a set of three source schemas `sS`, `sT`, and `sSnT`, each with an\ninstance; `iSklSklCls1`, `iTsk`, and `iSnT` respectively. We have a target schema `sS_T_SnT_Sum`. We\nalso have mappings that take each source schema to the target schema. What we want is a construction\nsimilar to eval that can be applied to a mapping rather than a query, but the schema colimit is\ngiving us mappings not queries.\n\nRecall that queries generalize mappings. It so happens there are three constructions that are \nrelated to eval in the same way mappings are related to queries. In fact eval and it's dual coeval,\nwhich we have not discussed, are generalizations of these constructions. To develop these ideas\nwould be a lengthy digression so we will only mention them in passing along with some informal\nremarks about their properties. \n\nThese three constructions are called sigma, pi and delta. They all can be understood as moving \ninstance data through mappings in a way that is analogous to how eval moves instances through \nqueries. This family of functors collectively define AQL's implementation of Extration, \nTransformation and Load abbreviated ETL processes. Sigma, pi and delta are all structure \npreserving maps between the category of instances of one schema to the category of instances of \nanother schema, so they are functors. This means that sigma, pi and delta map not only instances \nbut instance transforms. These three mappings are related as follows. Delta pulls data backward \nthrough a mapping and generalizes the notion of projection. Both Sigma and Pi push data forward \nthrough a mapping and generalize sums/unions and products/joins respectively. Given a single \nschema mapping, Delta can be paired with sigma on the left and pi on the right to create data \nmigration round trips.\n\nTo see this, consider schemas `sA`, `sB`, mapping `m` and instance `iA` of `sA`. Without yet\nspecifying specifics the AQL syntax would be:\n \n    mapping m = literal : sA -> sB {...} \n    instance iB = literal : sB {...}\n\nDelta can move the instance `iB` backward through `m` into `sA` as follows:\n \n    instance iDlt_m_iB = delta m iB\n \nSimilarly, sigma can move this new instance forward through the same `m` into `sB`:\n \n    instance iSgmDlt_m_iB = sigma m iDlt_m_iB\n \nA natural thing to ask is how `iSgmDlt_m_iB` and `iB` are related. The answer is they are related by\na transform known as the unit of the sigma --| delta adjoint pair. Notice we could also start\nwith an instance `iA` of `sA` and apply first sigma `m` and then delta `m` to product an instance \n`iDltSgm_m_iA`. `iA` and `iDltSgm_m_iA` are related by the counit of the sigma --| delta adjoint pair. \nIn a similar way delta --| pi form an adjoint pair with associated unit and counit transforms. \nWe say that delta is right adjoint to sigma and left adjoint to pi.\n\nOf the three, sigma has the property that generators of the source instance are preserved in the \ntarget instance. This means we can move instances and transforms between schemas in a way that \npermits us to merge instance data. Let's see how we can use sigma to solve the problem at hand\nand later we will return to broader questions about the nature of sigma, pi and delta and their\nassociated units and counits.\n\nRecall we have a target schema that contains all of the entities from our three source schemas\nwe can use the sigma construction to push the instances in the source schemas forward through the \nmappings generated by the `schema_colimit` construction to create an instance in the `sS_T_SnT_Sum`\nassembly. Having done so we would have three separate instances in the target schema \n`sS_T_SnT_Sum`. With all of these instances in the same schema we can make use of our familiar\ninstance coproduct construction. This would look like the following:\n\n    instance iSklSklCls_In_S_T_SnT_Sum = sigma mSToS_T_SnT_Sum iSklSklCls1\n    instance iTsk_In_S_T_SnT_Sum = sigma mSToT_T_SnT_Sum iTsk\n    instance iSnT_In_S_T_SnT_Sum = sigma mSnTToS_T_SnT_Sum iSnT\n    instance iS_T_SnT_Sum = coproduct\n        iSklSklCls_In_S_T_SnT_Sum\n        iTsk_In_S_T_SnT_Sum\n        iSnT_In_S_T_SnT_Sum\n        : sS_T_SnT_Sum\n    \nAQL provides the `coproduct_sigma` construction which performs the above sequence in one step:\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iS_T_SnT_Sum)) = (instanceExp coproduct_sigma (instanceCoProdPair (mappingKind (mappingRef (symbol mSToS_T_SnT_Sum))) (instanceKind (instanceRef (symbol iSklSklCls1)))) (instanceCoProdPair (mappingKind (mappingRef (symbol mTToS_T_Snt_Sum))) (instanceKind (instanceRef (symbol iTsk)))) (instanceCoProdPair (mappingKind (mappingRef (symbol mSnTToS_T_SnT_Sum))) (instanceKind (instanceRef (symbol iSnT)))) : (schemaKind (schemaRef (symbol sS_T_SnT_Sum)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## AQL Queries Continued\n \nIn the current context we have as source schema the result of the colimit construction. If you\nrun this file and look at the colimit schema `sS_T_SnT_Sum` and associated instance you will\ndiscover the we have assembled a target schema where the entities of the source schemas \nare independent of one another. We now use the query construction to introduce foreign key \nconstraints in a way that is analogous to the addition of the foreign key constraints supported \nin RDBMSs.\n\nRecall that a non-simple AQL query requires we define the target schema first. This schema is\nidentical to the output of the colimit construction but with the addition of a pair of foreign\nkeys from the `SkillNdFrTask` entity with the (skill, task) attribute pair to the Skill and Task \nentities respectively. This produces a schema which is known in category theory as a span and it \ncan again be summarized as a diagram, but in contrast with the case of the colimit construction \nthis is a diagram of entities rather than schemas. We have enclosed the `Skill` and `SkillClass` \nentities with parentheses to indicate that they serve as a reference taxonomy.\n\n              fk_HasClass    fk_SnT_S             fk_SnT_T\n    (SkillClass <----- Skill) <----- SkillNdFrTask -----> Task\n    \nWe again make use of the `observation_equations` section to denormalize all of the attributes that \nare available through paths as attributes directly available to the `SkillNdFrTask` entity.\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sSTSpn)) = (schemaExp literal : (typesideKind (typesideRef (symbol TypeSide))) { (schemaLiteralSection entities (schemaEntityId (symbol Skill)) (schemaEntityId (symbol SkillClass)) (schemaEntityId (symbol Task)) (schemaEntityId (symbol SkillNdFrTask)) foreign_keys (schemaForeignSig (schemaForeignId (symbol fk_HasClass)) : (schemaEntityId (symbol Skill)) -> (schemaEntityId (symbol SkillClass))) (schemaForeignSig (schemaForeignId (symbol fk_SkillNeeded)) : (schemaEntityId (symbol SkillNdFrTask)) -> (schemaEntityId (symbol Skill))) (schemaForeignSig (schemaForeignId (symbol fk_ForTask)) : (schemaEntityId (symbol SkillNdFrTask)) -> (schemaEntityId (symbol Task))) attributes (schemaAttributeSig (schemaAttributeId (symbol SName)) : (schemaEntityId (symbol Skill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol SCNameOnSkl)) : (schemaEntityId (symbol Skill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol SCName)) : (schemaEntityId (symbol SkillClass)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol TName)) : (schemaEntityId (symbol Task)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol skill)) : (schemaEntityId (symbol SkillNdFrTask)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol skillclass)) : (schemaEntityId (symbol SkillNdFrTask)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol task)) : (schemaEntityId (symbol SkillNdFrTask)) -> (typesideTypeId (symbol Varchar))) observation_equations (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol SCNameOnSkl)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_HasClass)))) . (schemaArrowId (schemaEntityId (symbol SCName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol skill)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_SkillNeeded)))) . (schemaArrowId (schemaEntityId (symbol SName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol skillclass)))) = (schemaPath (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_SkillNeeded)))) . (schemaArrowId (schemaEntityId (symbol fk_HasClass)))) . (schemaArrowId (schemaEntityId (symbol SCName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol task)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_ForTask)))) . (schemaArrowId (schemaEntityId (symbol TName))))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nGiven the similarity of the source and target schemas the entity sub-sections are all direct\nmappings that reproduce exact copies of the source entities instances with those of the target\nentities with the exception of the `SkllNdFrTask` target entity. In order to construct that entity \nwe must have generators on both sides of the new foreign keys we are introducing. By default when\nmultiple source generator variables are provided for a target entity each generator for the \ntarget comes from the Cartesian product of the source generators. The where clause has two\nequations implicitly connected by a logical and. This effectively constrains the target entities\nto an equationally defined subset of a Cartesian product, also known as a join, so this \nconstruction effectively joins the three source entities and makes all of their generators\navailable for the creation of the new foreign keys. The foreign keys can now be assigned the\nvalues for the `Skill` and `Task` generators based on the values in the `SkillNdFrTask` section.\n"  *) })) (kindDeclaration (queryAssignment query (queryId (symbol qS_T_SnT_SumToSTSpn)) = (queryExp literal : (schemaKind (schemaRef (symbol sS_T_SnT_Sum))) -> (schemaRef (symbol sSTSpn)) { (queryLiteralSection entity (queryEntityExpr (schemaEntityId (symbol Skill)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol ss)) : (schemaEntityId (symbol lSkill))) attributes (queryPathMapping (queryGen (symbol SName)) -> (queryPath (queryGen (symbol ss)) . (schemaArrowId (schemaEntityId (symbol lSName))))) (queryPathMapping (queryGen (symbol SCNameOnSkl)) -> (queryPath (queryGen (symbol ss)) . (schemaArrowId (schemaEntityId (symbol lSCNameOnSkl))))) foreign_keys (queryForeignSig (schemaForeignId (symbol fk_HasClass)) -> { (queryPathMapping (queryGen (symbol scsc)) -> (queryPath (queryGen (symbol ss)) . (schemaArrowId (schemaEntityId (symbol lfk_HasClass))))) }) allOptions) }) entity (queryEntityExpr (schemaEntityId (symbol SkillClass)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol scsc)) : (schemaEntityId (symbol lSkillClass))) attributes (queryPathMapping (queryGen (symbol SCName)) -> (queryPath (queryGen (symbol scsc)) . (schemaArrowId (schemaEntityId (symbol lSCName))))) allOptions) }) entity (queryEntityExpr (schemaEntityId (symbol SkillNdFrTask)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol snt)) : (schemaEntityId (symbol lSkillNeededForTask))) (queryClauseFrom (queryGen (symbol sn)) : (schemaEntityId (symbol lSkill))) (queryClauseFrom (queryGen (symbol nt)) : (schemaEntityId (symbol lTask))) where (queryClauseWhere (queryPath (queryGen (symbol snt)) . (schemaArrowId (schemaEntityId (symbol lskill)))) = (queryPath (queryGen (symbol sn)) . (schemaArrowId (schemaEntityId (symbol lSName))))) (queryClauseWhere (queryPath (queryGen (symbol snt)) . (schemaArrowId (schemaEntityId (symbol ltask)))) = (queryPath (queryGen (symbol nt)) . (schemaArrowId (schemaEntityId (symbol lTName))))) attributes (queryPathMapping (queryGen (symbol skill)) -> (queryPath (queryGen (symbol snt)) . (schemaArrowId (schemaEntityId (symbol lskill))))) (queryPathMapping (queryGen (symbol skillclass)) -> (queryPath (queryGen (symbol sn)) . (schemaArrowId (schemaEntityId (symbol lfk_HasClass))) . (schemaArrowId (schemaEntityId (symbol lSCName))))) (queryPathMapping (queryGen (symbol task)) -> (queryPath (queryGen (symbol snt)) . (schemaArrowId (schemaEntityId (symbol ltask))))) foreign_keys (queryForeignSig (schemaForeignId (symbol fk_SkillNeeded)) -> { (queryPathMapping (queryGen (symbol ss)) -> (queryPath (typesideConstantId sn))) }) (queryForeignSig (schemaForeignId (symbol fk_ForTask)) -> { (queryPathMapping (queryGen (symbol tt)) -> (queryPath (typesideConstantId nt))) }) allOptions) }) entity (queryEntityExpr (schemaEntityId (symbol Task)) -> { (queryClauseExpr from (queryClauseFrom (queryGen (symbol tt)) : (schemaEntityId (symbol lTask))) attributes (queryPathMapping (queryGen (symbol TName)) -> (queryPath (queryGen (symbol tt)) . (schemaArrowId (schemaEntityId (symbol lTName))))) allOptions) }) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nPushing the instance generated by the `coproduct_sigma` construction through the query above using\neval produces an instance reflecting the foreign keys introduced in the target schema we set up \nas part of the query definition.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSTSpn)) = (instanceExp eval (queryKind (queryRef (symbol qS_T_SnT_SumToSTSpn))) (instanceKind (instanceRef (symbol iS_T_SnT_Sum)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\n---\n\n## JDBC Pragmas, Imports and Exports\n\nThis first sequence exports the `iSTSpn` created above. Exporting a JDBC instance consolidates\nseveral sets of commands. First the export issues data definition (DDL) commands against the\ntarget RDBMS that create tables and foreign keys that are as close as possible to the associated\nAQL schema kind. The second sequence of commands inserts instance records into the tables just \ncreated. Since this file can be executed several times we must first check to see if the table\nstructure already exists and if so drop those tables. This task is performed using the pragma\n`pCleanUp`. In order to display the results of these commands the set of tables in the target schema\nare listed using the `pShwTbls` pragma.\n\nFirst clean out the target tables if present from a previous run.\n"  *) })) (kindDeclaration (commandAssignment command (commandId (symbol pCleanUp)) = (commandExp exec_jdbc (commandJdbcClass (quotedString "com.mysql.jdbc.Driver")) (commandJdbcUri (quotedString "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr")) { (commandExecJdbcSection (quotedMultiString "DROP TABLE IF EXISTS sts_SkillNdFrTask") (quotedMultiString "DROP TABLE IF EXISTS sts_Skill") (quotedMultiString "DROP TABLE IF EXISTS sts_SkillClass") (quotedMultiString "DROP TABLE IF EXISTS sts_Task") allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nExport the results of the above construction of the span and its representative instance. The\n`export_jdbc_instance` defaults strings varchar(64). In this case we illustrate how that default \ncan be overridden using the varchar_length option.\n"  *) })) (kindDeclaration (commandAssignment command (commandId (symbol eSTS)) = (commandExp export_jdbc_instance (transformRef (symbol iSTSpn)) (commandJdbcClass (quotedString "com.mysql.jdbc.Driver")) (commandJdbcUri (quotedString "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr")) (commandPrefixDst (quotedString "sts_")) { (commandExportJdbcSection (allOptions options (optionsDeclaration (varcharLengthOption varchar_length = 256)))) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nDisplay the contents of the `ci_test` schema in MySQL.\n"  *) })) (kindDeclaration (commandAssignment command (commandId (symbol pShwTbls)) = (commandExp exec_jdbc (commandJdbcClass (quotedString "com.mysql.jdbc.Driver")) (commandJdbcUri (quotedString "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr")) { (commandExecJdbcSection (quotedMultiString "SHOW  TABLES") allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nThe default AQL import process from a relational database submits an SQL query through the JDBC\ndriver for the source RDBMS for each entity declared in the target schema `sSTSpn` above. Due to\nthe extensive differences between AQL and RDBMS semantics, the translation process has a number\nof different options that can be used to provide flexibility. We make use of the default behavior\nfor this import but will return to import options in a later example. The import defaults require\na complete specification of all foreign key and attribute columns.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSTSpnImp)) = (instanceExp import_jdbc (jdbcClass "com.mysql.jdbc.Driver") (jdbcUri "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr") : (schemaKind (schemaRef (symbol sSTSpn))) { (instanceImportJdbcSection (schemaEntityId (symbol Skill)) -> (instanceSql "select id, fk_HasClass, SName, SCNameOnSkl from sts_Skill") (schemaEntityId (symbol SkillClass)) -> (instanceSql "select id, SCName from sts_SkillClass") (schemaEntityId (symbol Task)) -> (instanceSql "select id, TName from sts_Task") (schemaEntityId (symbol SkillNdFrTask)) -> (instanceSql "select id, fk_SkillNeeded, fk_ForTask, skill, task, skillclass from sts_SkillNdFrTask") allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nHaving constructed a span modeling the way skills are related to tasks, we now turn to another\nmodel involving a span relating skills to people. We could build this model up piece by piece as\nwe did above, but AQL's schema declaration can build such a schema in one step. To illustrate a\nmore elaborate example of AQL's integration capabilities the set of tables used to model skills \nfor this schema has an additional level to the taxonomy. The creation of this schema is a\nprecondition for the upcoming import. In order to extract existing data from a relational \ndatabase into an AQL schema we must first define an AQL schema that is compatible with the\nexternal SQL system. The schema below defines the structure into which we target our import.\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sSPSpn)) = (schemaExp literal : (typesideKind (typesideRef (symbol TypeSide))) { (schemaLiteralSection entities (schemaEntityId (symbol SpecificSkill)) (schemaEntityId (symbol GeneralSkill)) (schemaEntityId (symbol SkillClass)) (schemaEntityId (symbol Person)) (schemaEntityId (symbol SkillPrvdByPerson)) foreign_keys (schemaForeignSig (schemaForeignId (symbol fk_IsType)) : (schemaEntityId (symbol SpecificSkill)) -> (schemaEntityId (symbol GeneralSkill))) (schemaForeignSig (schemaForeignId (symbol fk_HasClass)) : (schemaEntityId (symbol GeneralSkill)) -> (schemaEntityId (symbol SkillClass))) (schemaForeignSig (schemaForeignId (symbol fk_SpP_S)) : (schemaEntityId (symbol SkillPrvdByPerson)) -> (schemaEntityId (symbol SpecificSkill))) (schemaForeignSig (schemaForeignId (symbol fk_SpP_P)) : (schemaEntityId (symbol SkillPrvdByPerson)) -> (schemaEntityId (symbol Person))) attributes (schemaAttributeSig (schemaAttributeId (symbol SSName)) (schemaAttributeId (symbol SSGSName)) (schemaAttributeId (symbol SSSCName)) : (schemaEntityId (symbol SpecificSkill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol GSName)) (schemaAttributeId (symbol GSSCName)) : (schemaEntityId (symbol GeneralSkill)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol SCName)) : (schemaEntityId (symbol SkillClass)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol PName)) : (schemaEntityId (symbol Person)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol skill)) : (schemaEntityId (symbol SkillPrvdByPerson)) -> (typesideTypeId (symbol Varchar))) (schemaAttributeSig (schemaAttributeId (symbol person)) : (schemaEntityId (symbol SkillPrvdByPerson)) -> (typesideTypeId (symbol Varchar))) observation_equations (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol SSGSName)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_IsType)))) . (schemaArrowId (schemaEntityId (symbol GSName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol SSSCName)))) = (schemaPath (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_IsType)))) . (schemaArrowId (schemaEntityId (symbol fk_HasClass)))) . (schemaArrowId (schemaEntityId (symbol SCName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol GSSCName)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_HasClass)))) . (schemaArrowId (schemaEntityId (symbol SCName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol skill)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_SpP_S)))) . (schemaArrowId (schemaEntityId (symbol SSName))))) (schemaObservationEquationSig (schemaPath (schemaArrowId (schemaEntityId (symbol person)))) = (schemaPath (schemaPath (schemaArrowId (schemaEntityId (symbol fk_SpP_P)))) . (schemaArrowId (schemaEntityId (symbol PName))))) allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nWe have already set up a set of tables and associated instance in our source RDBMS so we import\nthat instance using a command analogous to the `iSTSpnImp` imported instance.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSPSpnImp)) = (instanceExp import_jdbc (jdbcClass "com.mysql.jdbc.Driver") (jdbcUri "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr") : (schemaKind (schemaRef (symbol sSPSpn))) { (instanceImportJdbcSection (schemaEntityId (symbol SpecificSkill)) -> (instanceSql "select id, fk_IsType, SSName, SSGSName, SSSCName from sps_SpecificSkill") (schemaEntityId (symbol GeneralSkill)) -> (instanceSql "select id, fk_HasClass, GSName, GSSCName from sps_GeneralSkill") (schemaEntityId (symbol SkillClass)) -> (instanceSql "select id, SCName from sps_SkillClass") (schemaEntityId (symbol Person)) -> (instanceSql "select id, PName from sps_Person") (schemaEntityId (symbol SkillPrvdByPerson)) -> (instanceSql "select id, fk_SpP_S, fk_SpP_P, skill, person from sps_SkillPrvdByPerson") allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nIn this example we begin to see for the first time a more representative example of the full \ncapability of the `schema_colimit` construction. In this more interesting colimit we are gluing \n(equating) on a defined overlap that is associated with the slightly different strategies for \nmodeling skill taxonomies. In this case we are assuming that the Skill entity from `sSTSpn` can be\nequated with the `SpecificSkill` entity from `sSPSpn` and likewise the `SkillClass` entities from both. \nWe also note what this implies about foreign keys. Since `SpecificSkill` has a foreign key path \nthrough `GeneralSkill` we equate that path with the foreign key `fk_HasClass` from `sSTSpn`. In so \ndoing we consolidate the two schemas in a way that eliminates redundant entities and paths.\n\nGenerally this is what a colimit does. It merges multiple objects of a category into a single\nobject in a way that equates all paths from objects in the colimit diagram (in this case schemas)\nto the universal colimit (in this case the `schema_colimit`). These path equalities (in this case \nthe pair of paths from a link schema through `sSTSpn` and `sSPSpn` to `sSTSpn_SPSpn_CoLim`) serve to \ndefine ways in which structure is merged across the objects in the colimit diagram. Although this\napproach is supported by AQL there is an equivalent alternative. \n\nOne particularly intuitive way to implement a colimit involves deconstructing the colimit into \ntwo steps. The first step is to take the coproduct. The coproduct is a special case of a colimit \nwhere the colimit diagram consists of a set of discrete objects without any connecting arrows. \nWith such a diagram the colimit assembles the source objects disjointly. The second step is the \nquotient which provides for the merging of structure across and within the source objects. What \nis the structure being merged? It is the structure of a category, which consists of objects and \npaths.\n\nRecall the comparison we illustrated between the use of path equations in the instance \ndeclaration associated with `iSklSklCls1` and the use of a link instance and pair of transforms \nused in the construction of `isklSklCls2`. Similarly the following sequence follows the sequence\nyou have seen before where we disjointly assembled `sS`, `sT` and `sSnT`. In that sequence we followed\nwith a query to create foreign keys. In this sequence we are doing something different. Instead\nof joining a set of disjoint entities we are gluing a pair of schema with some shared structure.\n"  *) })) (kindDeclaration (schemaColimitAssignment schema_colimit (schemaColimitId (symbol STSpn_SPSpn_CoLimAuto)) = (schemaColimitExp quotient (schemaRef (symbol sSTSpn)) + (schemaRef (symbol sSPSpn)) : (typesideRef (symbol TypeSide)) { (schemaColimitQuotientSection entity_equations (scEntityPath (schemaRef (symbol sSTSpn)) . (schemaTermId (schemaEntityId (symbol Skill)))) = (scEntityPath (schemaRef (symbol sSPSpn)) . (schemaTermId (schemaEntityId (symbol SpecificSkill)))) (scEntityPath (schemaRef (symbol sSTSpn)) . (schemaTermId (schemaEntityId (symbol SkillClass)))) = (scEntityPath (schemaRef (symbol sSPSpn)) . (schemaTermId (schemaEntityId (symbol SkillClass)))) path_equations (scFkPath (schemaTermId (schemaEntityId (symbol sSTSpn_Skill_fk_HasClass)))) = (scFkPath (schemaRef (symbol sSPSpn_SpecificSkill_fk_IsType)) . (schemaTermId (schemaEntityId (symbol sSPSpn_GeneralSkill_fk_HasClass))))) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nAs we did in the construction of `S_T_SnT_Sum` we can relabel components in the colimit schema \nusing the modify command. An important point to notice is that attributes coming from different\nsource schemas must be maintained as distinct attributes in the colimit. This must be done even\nthough conceptually they may duplicate one another. This is essential as there is no guarantee\nthat different sources will be consistent in labeling equivalent records.\n"  *) })) (kindDeclaration (schemaColimitAssignment schema_colimit (schemaColimitId (symbol STSpn_SPSpn_CoLim)) = (schemaColimitExp modify (schemaColimitRef (symbol STSpn_SPSpn_CoLimAuto)) { (schemaColimitModifySection rename entities (scEntityPath (schemaTermId (schemaEntityId (symbol sSPSpn_GeneralSkill)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol GeneralSkill)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSPSpn_Person)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol Person)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSPSpn_SkillClass__sSTSpn_SkillClass)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol SkillClass)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSPSpn_SkillPrvdByPerson)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol SkillPrvdByPerson)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSPSpn_SpecificSkill__sSTSpn_Skill)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol SpecificSkill)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSTSpn_SkillNdFrTask)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol SkillNdFrTask)))) (scEntityPath (schemaTermId (schemaEntityId (symbol sSTSpn_Task)))) -> (scEntityPath (schemaTermId (schemaEntityId (symbol Task)))) rename foreign_keys (scFkPath (schemaRef (symbol SkillNdFrTask)) . (schemaTermId (schemaEntityId (symbol sSTSpn_SkillNdFrTask_fk_SkillNeeded)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol fk_SkillNeeded)))) (scFkPath (schemaRef (symbol SkillNdFrTask)) . (schemaTermId (schemaEntityId (symbol sSTSpn_SkillNdFrTask_fk_ForTask)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol fk_ForTask)))) (scFkPath (schemaRef (symbol SkillPrvdByPerson)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SkillPrvdByPerson_fk_SpP_S)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol fk_SpP_S)))) (scFkPath (schemaRef (symbol SkillPrvdByPerson)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SkillPrvdByPerson_fk_SpP_P)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol fk_SpP_P)))) (scFkPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SpecificSkill_fk_IsType)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol fk_IsType)))) (scFkPath (schemaRef (symbol GeneralSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_GeneralSkill_fk_HasClass)))) -> (scFkPath (schemaTermId (schemaEntityId (symbol fk_HasClass)))) rename attributes (scAttrPath (schemaRef (symbol SkillNdFrTask)) . (schemaTermId (schemaEntityId (symbol sSTSpn_SkillNdFrTask_skillclass)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_SCNameOnSnT)))) (scAttrPath (schemaRef (symbol SkillClass)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SkillClass_SCName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_SCName)))) (scAttrPath (schemaRef (symbol SkillNdFrTask)) . (schemaTermId (schemaEntityId (symbol sSTSpn_SkillNdFrTask_task)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_TNameOnSnT)))) (scAttrPath (schemaRef (symbol SkillPrvdByPerson)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SkillPrvdByPerson_skill)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_SNameOnSnT)))) (scAttrPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSTSpn_Skill_SName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_SklName)))) (scAttrPath (schemaRef (symbol Task)) . (schemaTermId (schemaEntityId (symbol sSTSpn_Task_TName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_TName)))) (scAttrPath (schemaRef (symbol SkillClass)) . (schemaTermId (schemaEntityId (symbol sSTSpn_SkillClass_SCName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_SCName)))) (scAttrPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSTSpn_Skill_SCNameOnSkl)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol ST_SCNameOnSS)))) (scAttrPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SpecificSkill_SSGSName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_GSNameOnSS)))) (scAttrPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SpecificSkill_SSName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_SSName)))) (scAttrPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SpecificSkill_SSSCName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_SCNameOnSS)))) (scAttrPath (schemaRef (symbol SkillPrvdByPerson)) . (schemaTermId (schemaEntityId (symbol sSPSpn_SkillPrvdByPerson_person)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_PNameOnSnP)))) (scAttrPath (schemaRef (symbol SkillNdFrTask)) . (schemaTermId (schemaEntityId (symbol sSTSpn_SkillNdFrTask_skill)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_SNameOnSnP)))) (scAttrPath (schemaRef (symbol Person)) . (schemaTermId (schemaEntityId (symbol sSPSpn_Person_PName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_PName)))) (scAttrPath (schemaRef (symbol GeneralSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_GeneralSkill_GSSCName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_SCNameOnGS)))) (scAttrPath (schemaRef (symbol GeneralSkill)) . (schemaTermId (schemaEntityId (symbol sSPSpn_GeneralSkill_GSName)))) -> (scAttrPath (schemaTermId (schemaEntityId (symbol SP_GSName)))) remove foreign_keys (scFkPath (schemaRef (symbol SpecificSkill)) . (schemaTermId (schemaEntityId (symbol sSTSpn_Skill_fk_HasClass)))) -> (scFkPath (schemaRef (symbol fk_IsType)) . (schemaTermId (schemaEntityId (symbol fk_HasClass))))) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nProvide addressable labels for the various components of the `schema_colimit` `STSpn_SPSpn_CoLim`.\n"  *) })) (kindDeclaration (schemaAssignment schema (schemaId (symbol sSTSpn_SPSpn_CoLim)) = (schemaExp getSchema (schemaColimitRef (symbol STSpn_SPSpn_CoLim))))) (kindDeclaration (mappingAssignment mapping (mappingId (symbol mSTSpnToSTSpn_SPSpn_CoLim)) = (mappingExp getMapping (schemaColimitRef (symbol STSpn_SPSpn_CoLim)) (schemaRef (symbol sSTSpn))))) (kindDeclaration (mappingAssignment mapping (mappingId (symbol mSPSpnToSTSpn_SPSpn_CoLim)) = (mappingExp getMapping (schemaColimitRef (symbol STSpn_SPSpn_CoLim)) (schemaRef (symbol sSPSpn))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nAgain as we did with the instances coming from the disjoint schemas `sS`, `sT`, and `sSnT`, we must deal \nwith the instance data coming from the two imports. We use `coproduct_sigma` to land those two\ninstances into the assembled `colimit_schema` of the two sources schemas `sSTSpn` and `sSPSpn`.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iST_SP_Sum)) = (instanceExp coproduct_sigma (instanceCoProdPair (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceKind (instanceRef (symbol iSTSpnImp)))) (instanceCoProdPair (mappingKind (mappingRef (symbol mSPSpnToSTSpn_SPSpn_CoLim))) (instanceKind (instanceRef (symbol iSPSpnImp)))) : (schemaKind (schemaRef (symbol sSTSpn_SPSpn_CoLim)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nIn order to make instance assembly clear we illustrate two equivalent methods. The second method \nhas the same preconditions as the first but performs the record linking transparently as part of\nthe import process. \n\nMerging records by importing a link table and transforms from tables constructed externally.\n\nIn this sequence we create external tables using SQL statements against the tables generated in\nthe export. The essence of this approach is matching records based on attributes. Clearly this\nwill only work if we can get exact string matches. This process can be generalized using any\nnumber of technical enhancements to include fuzzing matching using things like edit distance or\nmatching through machine learning approaches.\n\nAs is well known reliable integration depends on standardization and/or investment in the\nconstruction of translations between systems that make use of different reference information,\ne.g. skill classification in this case.\n"  *) })) (kindDeclaration (commandAssignment command (commandId (symbol pSetUpSkillMatch)) = (commandExp exec_jdbc (commandJdbcClass (quotedString "com.mysql.jdbc.Driver")) (commandJdbcUri (quotedString "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr")) { (commandExecJdbcSection (quotedMultiString "DROP TABLE IF EXISTS SkillMatch") (quotedMultiString "DROP TABLE IF EXISTS SkillClassMatch") (quotedMultiString "create table SkillMatch as\nselect\n  concat('s', t.id) as sm_id,\n  p.id as ps_id,\n  t.id as ts_id,\n  t.fk_HasClass\nfrom\n  sps_SpecificSkill p\n  join sts_Skill t\n    on p.SSName = t.SName\n  join sps_GeneralSkill gs\n    on p.fk_IsType = gs.id") (quotedMultiString "create table SkillClassMatch as\nselect\n  concat('sc', t.id) as scm_id,\n  p.id as psc_id,\n  t.id as tsc_id\nfrom\n  sps_SkillClass as p\n  join sts_SkillClass as t\n    on p.SCName = t.SCName") allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nWe import everything in one go using the `quotient_jdbc` import.\nIt is important to note that this does require the construction of the `SkillMatch` and\n`SkillClassMatch` tables in the source RDBMS as a precondition.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSTSpn_SPSpn_Merge2)) = (instanceExp quotient_jdbc (jdbcClass "com.mysql.jdbc.Driver") (jdbcUri "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr") (instanceKind (instanceRef (symbol iST_SP_Sum))) { (instanceQuotientJdbcSection (instanceQuotientJdbcName (schemaEntityId (symbol SpecificSkill))) -> (instanceSql "select\n   ps_id as sp_id,\n   ts_id as st_id\nfrom\n   SkillMatch") (instanceQuotientJdbcName (schemaEntityId (symbol SkillClass))) -> (instanceSql "select\n   psc_id as sp_id,\n   tsc_id as st_id\nfrom\n   SkillClassMatch") allOptions) }))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nPrior to wrapping up let's return to an examination of the data migration functors sigma, delta \nand pi as well as their connection with querying. We mentioned before that the `coproduct_sigma` \ncould be constructed into first the migration of instances separately into the colimit schema and \nthen taking the coproduct of each result. Let's examine what some of those intermediate steps do.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSTSpnImpInCoLim)) = (instanceExp sigma (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceKind (instanceRef (symbol iSTSpnImp)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nAs you can see by inspecting the runtime result we have loaded the instance `iSTSpnImp` into the\nassembled schema we created using the colimit. Since there are entities in the colimit schema\nnot present in `sSTSpn`. You will notice that some entities are empty; in particular, those \nentities that arose from `sSPSpn`. There are also Skolem terms that are generated due to the \nintroduction `GeneralSkill` referenced by `SpecialSkill` not present in `sSTSpn`.\n\nLet's close the loop using delta right adjoint to sigma. We present the instance generated by\nsigma above to delta at the same map. We have pushed `iSTSpnImp` forward through sigma and then\npulled the result back through the same schema map.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iSgmDltSTSpnImp)) = (instanceExp delta (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceKind (instanceRef (symbol iSTSpnImpInCoLim)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nWe see an instance that looks the same as `iSTSpnImp` originally imported. Intuitively we can think \nof this as delta projecting the part of the colimit schema instance back into the schema from \nwhich it came. It should not be surprising that this would yield the identity. This can be \nverified by looking at the unit transform and comparing it to the identity transform.\n"  *) })) (kindDeclaration (transformAssignment transform (transformId (symbol tUnit)) = (transformExp unit (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceRef (symbol iSTSpnImp))))) (kindDeclaration (transformAssignment transform (transformId (symbol tIdSTSpnImp)) = (transformExp identity (instanceRef (symbol iSTSpnImp))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nThe `SkillClass` transform output is not immediately obviously the identity, but if you unravel the \nprovenance you will find that it is. Start by looking at instance `iSTSpnImp` and you will see for\nentity Skill:\n\n    ID     SCNameOnSkl    fk_HasClass\n    ---    -----------    -----------\n    100    Cognitive      122\n    ...    ...            ...\n    102    Social         120\n    ...    ...            ...\n    105    Psychomotor    121\n\nNow look at the result of the quotient on the schema colimit in any of the three instances above, \nsay `iSTSpn_SPSpn_Merge3`. Specifically the `SkillClass` entity:\n\n    ID                             ST_SCName\n    ---------------------------    -----------\n    [100.fk_IsType.fk_HasClass]    Cognitive\n    [102.fk_IsType.fk_HasClass]    Social\n    [105.fk_IsType.fk_HasClass]    Psychomotor\n\nFinally look at the instance `iSgmDltSTSpnImp` and you will see for `SkillClass`:\n\n    ID                                         ST_SCName\n    ---------------------------------------    -----------\n    <SkillClass[100.fk_IsType.fk_HasClass]>    Cognitive\n    <SkillClass[102.fk_IsType.fk_HasClass]>    Social\n    <SkillClass[105.fk_IsType.fk_HasClass]>    Psychomotor\n\nWe can conclude:\n\n    <SkillClass[100.fk_IsType.fk_HasClass]>    -> 122\n    <SkillClass[102.fk_IsType.fk_HasClass]>    -> 120\n    <SkillClass[105.fk_IsType.fk_HasClass]>    -> 121 \n\nLet's try the other direction. We start with the merged instance in the schema colimit and use \ndelta to project back through the mapping that inserted the schema `sSTSpn` into the schema \ncolimit. As you would expect you loose almost all of the data that was supplied by `iSPSpnImp`. We \nnow have 11 skills rather than the 10 skills provided by `iSTSpnImp` and so have picked up an \nadditional Skolem term due to the \"dancing\" skill that came from `iSPSpnImp`.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iCoLimInSTSpn)) = (instanceExp delta (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceKind (instanceRef (symbol iSTSpn_SPSpn_Merge2)))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nSigma then pushes this projected instance back into the schema colimit and we end up with an\ninstance that looks like the one sigma pushed forward from `iSTSpnImp` but with the extra skill\nrecord. The round trip has eliminated all traces of `iSTSpn_SPSpn_Merge3` that came from `iSPSpnImp`\nexcept the record that additional \"Dancing\" skill that is now Skolemized.\n"  *) })) (kindDeclaration (instanceAssignment instance (instanceId (symbol iDltSgmCoLim)) = (instanceExp sigma (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceKind (instanceRef (symbol iCoLimInSTSpn)))))) (kindDeclaration (transformAssignment transform (transformId (symbol tCounit)) = (transformExp counit (mappingKind (mappingRef (symbol mSTSpnToSTSpn_SPSpn_CoLim))) (instanceRef (symbol iSTSpn_SPSpn_Merge2))))) (commentDeclarationSection (mdCommentDeclaration md { (*  "\nThe counit transform injects `iDltSgmColim` back into the merged instance `iSTSpn_SPSpn_Merge3`.\n"  *) })) (commentDeclarationSection (htmlCommentDeclaration html { (*  "\n</body></html>"  *) }))) <EOF>)