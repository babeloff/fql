package catdata.fqlpp.examples;

import catdata.ide.Example;
import catdata.ide.Language;

public class CatExample extends Example {
	
	@Override
	public Language lang() {
		return Language.FQLPP;
	}


	@Override
	public String getName() {
		return "Categories";
	}

	@Override
	public String getText() {
		return ret;
	}
	
	private final String ret = "//operations on finite categories"
			+ "\n"
			+ "\ncategory c1 = void"
			+ "\ncategory c2 = unit"
			+ "\ncategory c3 = (c2 + c2)"
			+ "\ncategory c4 = (c2 * c2)"
			+ "\ncategory c5 = (unit ^ void)"
			+ "\n"
			+ "\nfunctor f1 = id unit"
			+ "\nfunctor f2 = (f1 ; f1)"
			+ "\nfunctor f3 = ff unit"
			+ "\nfunctor f4 = iso1 c4 c5"
			+ "\nfunctor f5 = tt unit"
			+ "\n"
			+ "\nfunctor pair_eta = (fst c3 c3 * snd c3 c3) // = id"
			+ "\nfunctor sum_eta  = (inl c3 c3 + inr c3 c3) // = id"
			+ "\nfunctor exp_eta  = curry eval c3 c3 // = id"
			+ "\n"
			+ "\ncategory x = dom pair_eta"
			+ "\ncategory y = cod pair_eta"
			+ "\n"
			+ "\ncategory a = Set"
			+ "\ncategory b = Cat"
			+ "\nfunctor idSet = id Set"
			+ "\nfunctor idCat = id Cat"
			+ "\nfunctor idSet2 = (idSet ; idSet)"
			+ "\n"
			+ "\ntransform t1 = id idSet"
			+ "\ntransform t1x = (t1 ; t1) //on functors from Cat/Set, FQL can't check that cod/dom match, so be careful"
			+ "\ntransform t2 = id idCat"
			+ "\ntransform t3 = id exp_eta"
			+ "\ntransform t3x = (t3 ; t3)"
			+ "\n"
			+ "\n/////////////////////////////////////////////"
			+ "\n//finitely presented categories"
			+ "\n"
			+ "\ncategory C = {"
			+ "\n objects "
			+ "\n	T1, "
			+ "\n	T2,"
			+ "\n	string,"
			+ "\n	int;"
			+ "\n arrows"
			+ "\n	t1_ssn    : T1 -> string,"
			+ "\n	t1_first  : T1 -> string,"
			+ "\n	t1_last   : T1 -> string,"
			+ "\n	t2_first  : T2 -> string,"
			+ "\n	t2_last   : T2 -> string,"
			+ "\n	t2_salary : T2 -> int;"
			+ "\n equations; "
			+ "\n}"
			+ "\n"
			+ "\ncategory D = {"
			+ "\n objects "
			+ "\n	T,"
			+ "\n	string,"
			+ "\n	int;"
			+ "\n arrows"
			+ "\n	ssn    : T -> string,"
			+ "\n	first  : T -> string,"
			+ "\n	last   : T -> string,"
			+ "\n	salary : T -> int;"
			+ "\n equations;"
			+ "\n}"
			+ "\n"
			+ "\n//operations like product work on finitely presented categories "
			+ "\ncategory CD = (C * D)"
			+ "\n"
			+ "\n//finitely presented functors between finitely presented categories"
			+ "\nfunctor F = {"
			+ "\n objects "
			+ "\n	T1 -> T,"
			+ "\n	T2 -> T,"
			+ "\n	string -> string,"
			+ "\n	int -> int;"
			+ "\n arrows"
			+ "\n	t1_ssn    -> T.ssn,"
			+ "\n	t1_first  -> T.first,"
			+ "\n	t2_first  -> T.first,"
			+ "\n	t1_last   -> T.last,"
			+ "\n	t2_last   -> T.last,"
			+ "\n	t2_salary -> T.salary;"
			+ "\n} : C -> D"
			+ "\n"
			+ "\n//functors from finitely presented categories to Set "
			+ "\n//you can also use functions; see the Employees example"
			+ "\nset T = { XF667,XF891,XF221 } "
			+ "\nset string = { \"115-234\", \"112-988\", \"198-887\", Bob, Sue, Alice, Smith, Jones }"
			+ "\nset int = { 250, 300, 100 } "
			+ "\n"
			+ "\nfunctor J = {"
			+ "\n objects "
			+ "\n	T -> T,"
			+ "\n	string -> string, "
			+ "\n	int -> int;"
			+ "\n arrows"
			+ "\n	ssn    -> { (XF667, \"115-234\"),(XF891,\"112-988\"),(XF221,\"198-887\") }, // : T -> string is optional "
			+ "\n	first  -> { (XF667,Bob),(XF891,Sue),(XF221,Alice) } : T -> string,"
			+ "\n	last   -> { (XF667,Smith),(XF891,Smith),(XF221,Jones) } : T -> string,"
			+ "\n	salary -> { (XF667,250),(XF891,300),(XF221,100) } : T -> int;"
			+ "\n} : D -> Set"
			+ "\n"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////"
			+ "\n//functors from finitely presented categories to Cat"
			+ "\n"
			+ "\ncategory X = {"
			+ "\n objects "
			+ "\n	c, d;"
			+ "\n arrows"
			+ "\n	f : c -> d;"
			+ "\n equations; "
			+ "\n}"
			+ "\n"
			+ "\nfunctor Y = {"
			+ "\n objects"
			+ "\n     c -> C,"
			+ "\n     d -> D;"
			+ "\n arrows"
			+ "\n	f -> F;"
			+ "\n} : X -> Cat"
			+ "\n"
			+ "\n/////////////////////////////////////////////"
			+ "\n//Transforms between functors to Set"
			+ "\n"
			+ "\nfunctor X1 = {"
			+ "\n objects"
			+ "\n  c -> {1,2},"
			+ "\n  d -> {3,4};"
			+ "\n arrows"
			+ "\n  f -> {(1,3),(2,4)};"
			+ "\n} : X -> Set"
			+ "\n"
			+ "\nfunctor X2 = {"
			+ "\n objects"
			+ "\n  c -> {a,b,c},"
			+ "\n  d -> {d,e,f};"
			+ "\n arrows"
			+ "\n  f -> {(a,d),(b,e),(c,f)};"
			+ "\n} : X -> Set"
			+ "\n"
			+ "\ntransform X1X2 = {"
			+ "\n objects"
			+ "\n  c -> {(1,a),(2,b)},"
			+ "\n  d -> {(3,d),(4,e)};"
			+ "\n} : (X1 : X -> Set) -> (X2 : X -> Set)"
			+ "\n"
			+ "\n/////////////////////////////////////////////"
			+ "\n//Transforms between functors to Cat"
			+ "\n"
			+ "\nfunctor Z = {"
			+ "\n objects"
			+ "\n     c -> C,"
			+ "\n     d -> C;"
			+ "\n arrows"
			+ "\n	f -> id C;"
			+ "\n} : X -> Cat"
			+ "\n"
			+ "\ntransform ZY = {"
			+ "\n objects"
			+ "\n  c -> id C,"
			+ "\n  d -> F;"
			+ "\n} : (Z : X -> Cat) -> (Y : X -> Cat)"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////"
			+ "\n//Transforms between functors between finitely presented categories"
			+ "\n"
			+ "\ntransform FF = {"
			+ "\n objects"
			+ "\n  T1 -> T,"
			+ "\n  T2 -> T,"
			+ "\n  string -> string,"
			+ "\n  int -> int;	"
			+ "\n} : (F : C -> D) -> (F : C -> D)"
			+ "\n";


	
}
