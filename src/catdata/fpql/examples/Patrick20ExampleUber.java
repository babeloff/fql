package catdata.fpql.examples;

import catdata.ide.Example;
import catdata.ide.Language;

public class Patrick20ExampleUber extends Example {

	
	
	@Override
	public Language lang() {
		return Language.FPQL;
	}

	
	@Override
	public String getName() {
		return "Uber";
	}

	@Override
	public String getText() {
		return s;
	}
	
	private final String s = "//first, we declare our domain to have three values"
			+ "\ndom : type"
			+ "\n\"margo\" \"ryan\" \"david\" : dom"
			+ "\n"
			+ "\n/*"
			+ "\nNow we declare a schema:"
			+ "\n"
			+ "\nA(id, f, g) f,g foreign keys to B.id"
			+ "\nB(id, name)"
			+ "\n"
			+ "\nThis schema is meant to represent a \"has taught for relation\"."
			+ "\n */"
			+ "\nS = schema {"
			+ "\n	nodes A, B;"
			+ "\n	edges f:A->B, g:A->B, name:B->dom;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n/*"
			+ "\nFor example, this instance means that ryan taught for margo, and david taught for margo. "
			+ "\n "
			+ "\nI_A(x, r, m)"
			+ "\nI_A(y, d, m)"
			+ "\nI_B(r, \"ryan\")"
			+ "\nI_B(d, \"david\")"
			+ "\nI_B(m, \"margo\")"
			+ "\n*/"
			+ "\nI = instance {"
			+ "\n	variables x y : A, r d m : B;"
			+ "\n	equations x.f=r, x.g=m, y.f=d, y.g=m,"
			+ "\n	          r.name=\"ryan\", d.name=\"david\", m.name=\"margo\";"
			+ "\n} : S"
			+ "\n"
			+ "\n/*"
			+ "\n Here is an uber-flower to compute the reflexive closure"
			+ "\n of the \"has taught for relation\", or any relation on S. "
			+ "\n For each node in the target schema (also S), "
			+ "\n we give a set of conjunctive queries."
			+ "\n*/"
			+ "\nrefl_closure = polynomial {"
			+ "\n //this 'sub-query', called q1, copies B into B"
			+ "\n q1 = {for b:B; where; attributes name=b.name; edges;} : B,"
			+ "\n"
			+ "\n //q2 copies A to A.  For each a in A, we must specify, for edges f and g,"
			+ "\n //which ID in B to send a to.  We do that by giving"
			+ "\n //a valuation for q1's FOR-bound variables in terms of q2's variables"
			+ "\n //(technically, we are giving a homomorphism q2 -> q1)."
			+ "\n q2 = {for a:A; "
			+ "\n       where; "
			+ "\n       attributes; "
			+ "\n       edges f = {b=a.f} : q1,"
			+ "\n             g = {b=a.g} : q1;"
			+ "\n } : A, "
			+ "\n"
			+ "\n //q3 does reflexivity - for each b2 in B, we put b2 into A."
			+ "\n q3 = {for b2:B;"
			+ "\n       where;"
			+ "\n       attributes;"
			+ "\n       edges f = {b=b2} : q1,"
			+ "\n             g = {b=b2} : q1;"
			+ "\n } : A "
			+ "\n} : S -> S"
			+ "\n"
			+ "\n/*"
			+ "\nThe reflexive closure on our example I has 5 rows in I_A:"
			+ "\n"
			+ "\nI_A(x, r, m)"
			+ "\nI_A(y, d, m)"
			+ "\nI_A(r, r, r)"
			+ "\nI_A(d, d, d)"
			+ "\nI_A(m, m, m)"
			+ "\nI_B(r, \"ryan\")"
			+ "\nI_B(d, \"david\")"
			+ "\nI_B(m, \"margo\")"
			+ "\n*/"
			+ "\nI_refl = apply refl_closure I"
			+ "\n"
			+ "\n/*"
			+ "\n Here is an uber-flower to compute a 'transitivity step' "
			+ "\n of the \"has taught for relation\", or any relation on S.  "
			+ "\n As before, for each node in the target schema (also S), "
			+ "\n we give a set of conjunctive queries."
			+ "\n*/"
			+ "\ntrans_step = polynomial {"
			+ "\n //copies B into B"
			+ "\n q1 = {for b:B; where; attributes name=b.name; edges;} : B,"
			+ "\n"
			+ "\n //copies A into A"
			+ "\n q2 = {for a:A; "
			+ "\n       where; "
			+ "\n       attributes; "
			+ "\n       edges f = {b=a.f} : q1,"
			+ "\n             g = {b=a.g} : q1;"
			+ "\n } : A, "
			+ "\n"
			+ "\n //q3 does transitivity - for a1 and a2 in A, where a1.g = a2.f, we put (a1.f, a2.g) into A."
			+ "\n q3 = {for a1:A, a2:A;"
			+ "\n       where a1.g = a2.f;"
			+ "\n       attributes;"
			+ "\n       edges f = {b=a1.f} : q1,"
			+ "\n             g = {b=a2.g} : q1;"
			+ "\n } : A "
			+ "\n} : S -> S"
			+ "\n"
			+ "\n/*"
			+ "\nThe reflexive closure of our example I is already transitively closed,"
			+ "\nbut in FQL, unions are disjoint.  Hence, a transitivty step puts 12"
			+ "\nrows into A:"
			+ "\n"
			+ "\nI_A(0, r, m)"
			+ "\nI_A(1, r, m)"
			+ "\nI_A(2, r, m)"
			+ "\nI_A(3, r, r)"
			+ "\nI_A(4, r, r)"
			+ "\nI_A(5, d, m)"
			+ "\nI_A(6, d, m)"
			+ "\nI_A(7, d, m)"
			+ "\nI_A(8, d, d)"
			+ "\nI_A(9, d, d)"
			+ "\nI_A(10, m, m)"
			+ "\nI_A(11, m, m)"
			+ "\n*/"
			+ "\nI_refl_trans1 = apply trans_step I_refl"
			+ "\n"
			+ "\n//////////////"
			+ "\n"
			+ "\n//It's a little hard to read instances on schema S, so we "
			+ "\n//pull them back onto spans here:"
			+ "\n"
			+ "\nisa_schema_small = schema {"
			+ "\n	nodes A;"
			+ "\n	edges l : A -> dom, r : A -> dom;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\nM = mapping {"
			+ "\n	nodes A -> A;"
			+ "\n	edges l -> f.name, r -> g.name;"
			+ "\n} : isa_schema_small -> S "
			+ "\n"
			+ "\nI_small = delta M I"
			+ "\nI_refl_small = delta M I_refl"
			+ "\nI_trans_small = delta M I_refl_trans1"
			+ "\n"

;


}
