package catdata.aql.examples;

public class AqlJdbcExample extends AqlExample {

	@Override
	public String getName() {
		return "JDBC";
	}

	@Override
	public String getText() {
		return s;
	}

	private final String s = 
			"//create some example data in a local temporary sql database. (close delay keeps H2 database alive across connections)"
					+ "\npragma load = exec_jdbc \"org.h2.Driver\" \"jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1\" { "
					+ "\n\"DROP TABLE IF EXISTS Employee;"
					+ "\nDROP TABLE IF EXISTS Department;\" //multiple statements can be used, but many SQL engines (such as H2, AQL's internal engine) will only print the output of the first statement, and some require ?allowMultiQueries=true in the jdbc string "
					+ "\n"
					+ "\n\"CREATE TABLE Employee("
					+ "\n id INT PRIMARY KEY,"
					+ "\n name VARCHAR(255),"
					+ "\n manager INT,"
					+ "\n worksIn INT"
					+ "\n)\""
					+ "\n"
					+ "\n\"CREATE TABLE Department("
					+ "\n id INT PRIMARY KEY,"
					+ "\n name VARCHAR(255),"
					+ "\n secretary INT,"
					+ "\n)\""
					+ "\n "
					+ "\n\"INSERT INTO Employee VALUES "
					+ "\n (101, 'Alan', 103, 10), "
					+ "\n (102, 'Camille', 102, 2), "
					+ "\n (103, 'Andrey', 103, 10)\""
					+ "\n"
					+ "\n\"INSERT INTO Department VALUES"
					+ "\n (10, 'Applied Math', 101),"
					+ "\n (2, 'Pure Math', 102)\""
					+ "\n"
					+ "\n// options always_reload = true //true forces pragmas to not be cached between runs (i.e., always run)"
					+ "\n}  "
					+ "\n "
					+ "\n//look at the example data"
					+ "\npragma view0 = exec_jdbc \"org.h2.Driver\" \"jdbc:h2:mem:db1\" { "
					+ "\n\"SELECT * FROM Department\""
					+ "\n\"SELECT * FROM Employee\""
					+ "\n}"
					+ "\n"
					+ "\n////////////////////////////////////////////////////////////////////////////////////////////////////////"
					+ "\n"
					+ "\ntypeside Ty = literal { "
					+ "\n	java_types"
					+ "\n		string = \"java.lang.String\""
					+ "\n		nat = \"java.lang.Integer\""
					+ "\n	java_constants"
					+ "\n		string = \"return input[0]\""
					+ "\n		nat = \"return java.lang.Integer.parseInt(input[0])\""
					+ "\n	java_functions"
					+ "\n		plus : nat,nat -> nat = \"return (input[0] + input[1]).intValue()\""
					+ "\n}"
					+ "\n"
					+ "\nschema S = literal : Ty {"
					+ "\n	entities"
					+ "\n		Employee "
					+ "\n		Department"
					+ "\n	foreign_keys"
					+ "\n		manager   : Employee -> Employee"
					+ "\n		worksIn   : Employee -> Department"
					+ "\n		secretary : Department -> Employee"
					+ "\n	path_equations "
					+ "\n		manager.worksIn = worksIn"
					+ "\n  		secretary.worksIn = Department"
					+ "\n  		manager.manager = manager"
					+ "\n  	attributes"
					+ "\n  		first last	: Employee -> string"
					+ "\n     	age			: Employee -> nat"
					+ "\n     	cummulative_age: Employee -> nat"
					+ "\n     	name 		: Department -> string"
					+ "\n     observation_equations"
					+ "\n     	forall e. cummulative_age(e) = plus(age(e), age(manager(e)))"
					+ "\n}"
					+ "\n"
					+ "\n//import an instance by providing queries for each entity/foreign key/attribute (and optionally, type)"
					+ "\ninstance J = import_jdbc \"org.h2.Driver\" \"jdbc:h2:mem:db1\" : S {"
					+ "\n	Employee -> \"SELECT id FROM Employee\""
					+ "\n	Department -> \"SELECT id FROM Department\""
					+ "\n	manager -> \"SELECT id, manager FROM Employee\"  "
					+ "\n	worksIn -> \"SELECT id, worksIn FROM Employee\" "
					+ "\n	secretary -> \"SELECT id, secretary FROM Department\""
					+ "\n	first -> \"SELECT id, name FROM Employee\"	//use name as first name"
					+ "\n  	last	-> \"SELECT id, NULL FROM Employee\"   //use null as last name"
					+ "\n     age -> \"SELECT id, id FROM Employee\"	  //use id as age	"
					+ "\n     cummulative_age -> \"SELECT id, id FROM Employee WHERE FALSE\" //add no equations about cumulative age "
					+ "\n     name -> \"SELECT id, name FROM Department\"		  "
					+ "\n}"
					+ "\n"
					+ "\n//import a transform by providing queries for each entity (an optionally, type)"
					+ "\ntransform Jid = import_jdbc \"org.h2.Driver\" \"jdbc:h2:mem:db1\" : J -> J {"
					+ "\n	Employee -> \"SELECT id, id FROM Employee\""
					+ "\n	Department -> \"SELECT id, id FROM Department\""
					+ "\n}"
					+ "\n"
					+ "\n//export the instance to SQL"
					+ "\npragma store1 = export_jdbc_instance J \"org.h2.Driver\" \"jdbc:h2:mem:db1\" \"Exported\" "
					+ "\n"
					+ "\n//view exported SQL instance"
					+ "\npragma view1 = exec_jdbc \"org.h2.Driver\" \"jdbc:h2:mem:db1\" { "
					+ "\n	\"SELECT * FROM ExportedEmployee\""
					+ "\n	\"SELECT * FROM ExportedDepartment\""
					+ "\n}"
					+ "\n"
					+ "\n//export the transform to SQL"
					+ "\npragma store2 = export_jdbc_transform Jid \"org.h2.Driver\" \"jdbc:h2:mem:db1\" \"ExportedTrans\""
					+ "\n"
					+ "\n//view the exported SQL transform"
					+ "\npragma view2 = exec_jdbc \"org.h2.Driver\" \"jdbc:h2:mem:db1\" { "
					+ "\n	\"SELECT * FROM ExportedTransEmployee\""
					+ "\n	\"SELECT * FROM ExportedTransDepartment\""
					+ "\n}"
					+ "\n"
					+ "\n////////////////////////////////////////////////////////////"
					+ "\n//"
					+ "\n//execute command line actions as follows"
					+ "\n//pragma cmdline1 = exec_cmdline  { "
					+ "\n//\"ls -ltr\""
					+ "\n//\"echo hi\""
					+ "\n//}"
					+ "\n//"
					+ "\n//execute actions as follows"
					+ "\n//pragma js1 = exec_js  { "
					+ "\n//\"javax.swing.JOptionPane.showMessageDialog(null, \\\"hello1\\\")\""
					+ "\n//\"javax.swing.JOptionPane.showMessageDialog(null, \\\"hello2\\\")\""
					+ "\n//}"
					+ "\n"
;



}
