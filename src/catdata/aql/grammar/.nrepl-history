(def aql (antlr/parser "aql.g4"))
(def aql (antlr/parser "Aql.g4"))
(def aql (antlr/parser "AqlCommentTest.g4"))
aql
(slurp 
)
(doc slurp)
(slurp "AqlComment.aql")
(aql (slurp "AqlComment.aql"))
(def aql (antlr/parser "AqlCommentTest.g4"))
(aql (slurp "AqlComment.aql"))
(def hello (antlr/parser "Hello.g4"))
(hello "foo")
(hello "hello foo")
(def hello (antlr/parser "Hello.g4"))
(def he (antlr/parser "Hello.g4"))
(def hello (antlr/parser "Hello.g4"))
(def hello (antlr/parser "HelloLexer.g4"))
(def aql (antlr/parser "AqlCommentTest.g4"))
(import '(java.lang ThreadLocal) org.antlr.v4.Tool '(org.antlr.v4.tool LexerGrammar Grammar) '(org.antlr.v4.parse ANTLRParser) '(org.antlr.v4.runtime CommonTokenStream Lexer LexerInterpreter Parser ParserInterpreter) org.antlr.v4.runtime.tree.ParseTree)
(def aql (antlr/parser "AqlCommentTest.g4"))
(aql (slurp "AqlCommentTest.aql"))
(aql (slurp "AqlCommentSample.aql"))
(def aql (antlr/parser "AqlCommentTest.g4"))
(aql (slurp "AqlCommentSample.aql"))
(antlr4 :grammar "AqlCommentTest.g4")
(def antlr (antlr4 :grammar "AqlCommentTest.g4"))
(def aql (antlr4 :grammar "AqlCommentTest.g4"))
(aql (slurp "AqlCommentSample.aql"))
(def antlr (antlr4 :grammar "AqlCommentTest.g4" :show))
(def antlr (antlr4 :grammar "AqlCommentTest.g4" :show 5))
(def key1 "-atn")
(def key2 ["-atn" "-no-atn"])
(len key1)
(length key1)
(count key1)
(count key2)
(seq? key2)
(seq? key1)
key2
(sequential? key1)
(sequential? key2)
(def antlr (antlr4 :grammar "AqlCommentTest.g4" :show 5))
(def aql (antlr4 :grammar "AqlCommentTest.g4" :show 5))
aql
(def aql (antlr4 :grammar "AqlCommentTest.g4" :show 5))
(def aql (boot (antlr4 :grammar "AqlCommentTest.g4" :show 5)))
(def aql (boot (antlr4 :grammar "AqlCommentTest.g4" :show 5))
)
(boot (antlr4 :grammar "AqlCommentTest.g4" :show 5))
(boot (antlr4 :grammar "AqlCommentTest.g4" :show ))
(boot (antlr4 :grammar "AqlCommentTest.g4" :show true ))
(boot (antlr4 :show true ))
target
(def target)
(boot (antlr4 :show true ))
(boot (antlr4 :grammar "AqlCommentTest.g4" :show true ))
(def items [])
(first items)
(first items
(boot (antlr4 :grammar "AqlCommentTest.g4" :show true ))
(def key ["-listener" "-no-listener"])
(doc name)
(def option ["-listener" "-no-listener"])
(def object )
(if object (first option) (second option)
)
(def object nil)
(if object (first option) (second option))
(if nil "f" "j")
(import 'AqlLexer)
(AqlLexer.)
(AqlLexer. nil)
(def lex (AqlLexer. nil))
(def lex (AqlRulesLexer. nil))
(def lex (AqlLexerRules. nil))
(def file-path "resource/sample/AqlOptionsSample.aql")
(require '(me.raynes [fs :as fs]))
(fs/split file-path)
(->> (fs/split file-path)
       (map #(case % ".." "dots" "." "dot" %)))
(->> (fs/split file-path)
       (map #(case % ".." "dots" "." "dot" %))
       doall))
(defn get-target-path
  [file-path]
  (->> (fs/split file-path)
       (map #(case % ".." "dots" "." "dot" %))))
(require '(clojure.java [io :as io]))
(get-target-path file-path)
(def tgt-file-path (get-target-path file-path))
(io/file target-dir tgt-file-path "token.txt")
(def target-dir "foo/bar")
(io/file target-dir tgt-file-path "token.txt")
(apply io/file (flatten target-dir tgt-file-path "token.txt"))
(apply io/file (flatten [target-dir tgt-file-path "token.txt"]))
(apply io/file (concat [target-dir] tgt-file-path ["token.txt"]))
(def tgt-dir (apply io/file target-dir tgt-file-path))
tgt-dir
(def fs (java.nio.file.FileSystems/getDefault))
(def gm (.getPathMatcher fs "glob:*.{g4,md}"))
(def d (.getPath fs "."))
(with-open [ch (file/walk "." 1)] (first (stream/stream-seq ch))) 
(require
  '(boot [core :as boot :refer [deftask]]
         [util :as util]
         [task-helpers :as helper])
  '(babeloff
    [boot-antlr4 :as antlr]
    [boot-antlr4-parser :as parser])
  '(clojure.spec [alpha :as s])
  '(clojure.java [io :as io])
  '(ike.cljj [file :as file]))
(with-open [ch (file/walk "." 1)] (first (stream/stream-seq ch)))
(require
  '(boot [core :as boot :refer [deftask]]
         [util :as util]
         [task-helpers :as helper])
  '(babeloff
    [boot-antlr4 :as antlr]
    [boot-antlr4-parser :as parser])
  '(clojure.spec [alpha :as s])
  '(clojure.java [io :as io])
  '(ike.cljj [file :as file]
             [strean :as stream]))
(require
  '(boot [core :as boot :refer [deftask]]
         [util :as util]
         [task-helpers :as helper])
  '(babeloff
    [boot-antlr4 :as antlr]
    [boot-antlr4-parser :as parser])
  '(clojure.spec [alpha :as s])
  '(clojure.java [io :as io])
  '(ike.cljj [file :as file]
             [stream :as stream]))
(with-open [ch (file/walk "." 1)] (first (stream/stream-seq ch)))
(with-open [ch (file/walk "." 1)] (take 4 (stream/stream-seq ch)))
(with-open [ch (file/walk "." 1)] (second (stream/stream-seq ch)))
(with-open [ch (file/walk "." 1)] (-> (stream/stream-seq ch) ))
(with-open [ch (file/walk "." 1)] (-> (stream/stream-seq ch) (into []))
)
(with-open [ch (file/walk "." 1)] (into [] (map .getFileName (stream/stream-seq ch) ))
)
(with-open [ch (file/walk "." 1)] (into [] (map .getFileName) (stream/stream-seq ch) )))
(with-open [ch (file/walk "." 1)] (into [] (map .getFileName) (stream/stream-seq ch) ))
(file/walk ".")
(into [] (map .getFileName) (file/walk path))
(def path ".")
(into [] (map .getFileName) (file/walk path))
(into [] (map #(.getFileName %)) (file/walk path))
(into [] (map #(.getFileName %)) (file/walk path 1))
(defn foo [x & y] (type y))
(foo 4 6 6 8)
(defn foo [x & y] (into-array Integer y))
(foo 4 6 6 8)
(defn foo [x & y] (into-array Object y))
(foo 4 6 6 8)
(doc into-array)
(foo 4)
(Paths/get "." (into-array String []))
(def cwd (Paths/get "." (into-array String [])))
(def input-dir-str "../../../../resources/examples/aql")
(def input-dir cwd (Paths/get input-dir-str (into-array String [])))
(dnput-dir cwd (Paths/get input-dir-str (into-array String [])))
(def input-dir  (Paths/get input-dir-str (into-array String [])))
(def input-file-s 
        (with-open [children (Files/walk input-dir 1 fs (into-array FileVisitOption []))]
          (-> children .iterator iterator-seq))
)
(def input-dir-str "../../../../resources/examples/aql")
(def input-dir cwd (Paths/get input-dir-str (into-array String [])))
(def input-dir  (Paths/get input-dir-str (into-array String [])))
(def input-file-s
        (with-open [children (Files/walk input-dir 1 fs (into-array FileVisitOption []))]
          (-> children .iterator iterator-seq)))
(def input-file-s (with-open [children (Files/walk input-dir 1 (into-array FileVisitOption []))]
          (-> children .iterator iterator-seq)))
input-file-s
(with-open [children (Files/walk input-dir 1 (into-array FileVisitOption []))]
                       (-> children .iterator iterator-seq
                         (filter #(.isFile %))
                         (mapv #(.. % (asFile) (getAbsolutePath)))))
(with-open [children (Files/walk input-dir 1 (into-array FileVisitOption []))]
                       (-> children .iterator iterator-seq
                         (filter #(.isFile %)))
)
(with-open [children (Files/walk input-dir 1 (into-array FileVisitOption []))]
                       (-> children .iterator iterator-seq)))
(with-open [children (Files/walk input-dir 1 (into-array FileVisitOption []))]
                       (-> children .iterator iterator-seq))
(def input-dir-str "../../../../resources/examples/aql")
        (def input-dir (Paths/get input-dir-str empty-path-extention))
        (def input-file-s 
          (with-open [children (Files/walk input-dir 1 empty-file-visit-options)]
            (-> children .iterator iterator-seq
              (filter #(.isFile %))
              (mapv #(.. % (asFile) (getAbsolutePath))))))
input-dir
(def input-file-s 
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)])
          (-> children #(.iterator) iterator-seq
              (map #(.getFileName %))
              (filter #(.isFile %))
              (mapv #(.. % (asFile) (getAbsolutePath)))))
(def input-file-s 
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children #(.iterator) iterator-seq
                (map #(.getFileName %))
                (filter #(.isFile %))
                (mapv #(.. % (asFile) (getAbsolutePath))))))
(def no-path-extention (into-array String []))
(def no-file-visit-options (into-array FileVisitOption []))
(def input-file-s 
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children #(.iterator) iterator-seq
                (map #(.getFileName %))
                (filter #(.isFile %))
                (mapv #(.. % (asFile) (getAbsolutePath))))))
(def input-file-s
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children #(.iterator %) iterator-seq
                (map #(.getFileName %))
                (filter #(.isFile %))
                (mapv #(.. % (asFile) (getAbsolutePath))))))
(def input-file-s
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children #(.iterator %) iterator-seq
                (map #(.getFileName %)))
)
(def input-file-s
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children #(.iterator %) iterator-seq
                (map #(.getFileName %))))
)
(Files/walk input-dir 1 no-file-visit-options)
(def stream (Files/walk input-dir 1 no-file-visit-options) )
(.iterator stream)
(interator-seq (.iterator stream))
(iterator-seq (.iterator stream))
(def stream (Files/walk input-dir 1 no-file-visit-options) )
(iterator-seq (.iterator stream))
(def stream (Files/walk input-dir 1 no-file-visit-options) )
(.getFileName (iterator-seq (.iterator stream)))
(map (.getFileName %) (iterator-seq (.iterator stream)))
(map #(.getFileName %) (iterator-seq (.iterator stream)))
(def stream (Files/walk input-dir 1 no-file-visit-options) )
(map #(.getFileName %) (iterator-seq (.iterator stream)))
(map #(.toAbsolutePath %) (iterator-seq (.iterator stream)))
(def stream (Files/walk input-dir 1 no-file-visit-options) )
(map #(.toAbsolutePath %) (iterator-seq (.iterator stream)))
(def stream (Files/walk input-dir 1 no-file-visit-options) )
(map #(.toRealPath %) (iterator-seq (.iterator stream)))
(map #(.toRealPath %) (iterator-seq 
))))))
(map #(.toRealPath % (into-array ) (iterator-seq (.iterator stream)))
))))
(def no-path-extensions (into-array String []))
(def no-file-visit-options (into-array FileVisitOption []))
(def no-link-options (into-array LinkOption []))
(def input-dir-str "../../../../resources/examples/aql")
        (def input-dir (Paths/get input-dir-str no-path-extensions))
(def input-file-s
          (with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (map #(.toRealPath % no-link-options)
                (iterator-seq (.iterator children)))))
input-file-s
(def children (Files/walk input-dir 1 no-file-visit-options))
(map #(.toRealPath % no-link-options) (iterator-seq (.iterator children)))
(with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (map #(.toRealPath % no-link-options)
                (iterator-seq (.iterator children))))
(with-open [children (Files/walk input-dir 1 no-file-visit-options)]
            (map str 
              (map #(.toRealPath % no-link-options)
                (iterator-seq (.iterator children))))
)
(with-open [children (Files/walk input-dir 1 no-file-visit-options)] (map #(.toRealPath % no-link-options) (iterator-seq (.iterator children))))
(let [children (Files/walk input-dir 1 no-file-visit-options)] (map #(.toRealPath % no-link-options) (iterator-seq (.iterator children))))
(def input-file-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children 
              #(iterator-seq (.iterator %))
              #(map #(.toRealPath % no-link-options)))))
input-file-s
(def input-file-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            (-> children
              #(iterator-seq (.iterator %))
              (fn [sq]
                (map #(.toRealPath % no-link-options)
                     sq)))))
(def input-file-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            (->
              (iterator-seq (.iterator children))
              (fn [sq]
                (map #(.toRealPath % no-link-options)
                     sq)))))
(def input-file-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            (map #(.toRealPath % no-link-options)
                (iterator-seq (.iterator children)))))
input-file-s
(.getPathMatcher fs "glob:.{g4}"
)
(def fs (java.nio.file.FileSystems/getDefault))
        (def gm (.getPathMatcher fs "glob:.{g4}"))
(def input-raw-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            (map #(.toRealPath % no-link-options)
                (iterator-seq (.iterator children)))))
        (def fs (java.nio.file.FileSystems/getDefault))
(def input-raw-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            (map #(.toRealPath % no-link-options)
                (iterator-seq (.iterator children)))))
        (def fs (java.nio.file.FileSystems/getDefault))
(def gm (.getPathMatcher fs "glob:.{g4}"))
        (def input-file-s (filter #(.matches gm (.getName %)) input-raw-s))
input-file-s
(def input-file-s (filter #(.matches gm (.getFileName %)) input-raw-s))
input-file-s
input-raw-s
(def gm (.getPathMatcher fs "glob:.{aql}"))
        (def input-file-s (filter #(.matches gm (.getFileName %)) input-raw-s))
input-file-s
(-> input-raw-s first #(.getFileName %))
(-> input-raw-s first)
(def f (-> input-raw-s first))
(.getFileName f)
(-> input-raw-s first (fn [x] (.getFileName x)))
(macroexpand (-> input-raw-s first (fn [x] (.getFileName x))))
(defn get-file-name [f] (.getFileName f))
(-> input-raw-s first get-file-name)
(defn get-file-name [f] (.getFileName f))
(defn matches-aql [gm f] (.matches gm (get-file-name f)))
(def input-file-s (filter  #(matches-aql gm %1) input-raw-s))
input-file-s
input-raw-s
(def gm (get-path-matcher "glob:.{aql}"))
        (def input-file-s (filter  #(matches-aql gm %1) input-raw-s))
(defn get-path-matcher [pattern] 
  (.getPathMatcher (java.nio.file.FileSystems/getDefault) pattern)) 
(def gm (get-path-matcher "glob:.{aql}"))
        (def input-file-s (filter  #(matches-aql gm %1) input-raw-s))
input-file-s
(def gm (get-path-matcher "glob:*.{aql}"))
        (def input-file-s (filter  #(matches-aql gm %1) input-raw-s))
input-file-s
(mapv str input-file-s)
(let [children (Files/walk input-dir 1 no-file-visit-options)]
            ;(map #(.toRealPath % no-link-options)
            (iterator-seq (.iterator children)))
(def input-dir-str "../../../../resources/examples/aql")
        (def input-dir (Paths/get input-dir-str no-path-extensions))
        (def input-raw-s
          (let [children (Files/walk input-dir 1 no-file-visit-options)]
            ;(map #(.toRealPath % no-link-options)
            (iterator-seq (.iterator children))))
input-raw-s
