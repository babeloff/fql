package catdata.opl.examples;

import catdata.ide.Example;
import catdata.ide.Language;

public class OplPaperExample extends Example {

	@Override
	public String getName() {
		return "Paper";
	}

	@Override
	public String getText() {
		return s;
	}

	@Override
	public Language lang() {
		return Language.OPL;
	}
	
	private final String s = "MonoidActions = theory {"
			+ "\n	sorts"
			+ "\n		m, s;"
			+ "\n	symbols"
			+ "\n		n : m,"
			+ "\n		u : m,m -> m,"
			+ "\n		a : m,s -> s;"
			+ "\n	equations"
			+ "\n		forall x. u(x, n) = x,"
			+ "\n		forall x. u(n, x) = x,"
			+ "\n		forall x, y, z. u(x, u(y, z)) = u(u(x, y), z),"
			+ "\n		forall x, y, p. a(x, a(y, p)) = a(u(x, y), p);"
			+ "\n}"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//commutative rings (figure 2) kill the built-in theorem prover.  so instead,"
			+ "\n//we use an equational axiomatiztion of natural numbers that is easier to handle computationally."
			+ "\n//it behaves exactly the same for the examples in this file"
			+ "\nType = theory {"
			+ "\n	sorts "
			+ "\n		Nat, Bool, Char, Str;"
			+ "\n	symbols"
			+ "\n		zero@7 : Nat, "
			+ "\n		succ@8 : Nat -> Nat,"
			+ "\n       	\"+\"@9, \"*\"@10 : Nat, Nat -> Nat, //the @ define an operator precedence"
			+ "\n"
			+ "\n        	\"<=\" : Nat, Nat -> Bool,"
			+ "\n        	true, false : Bool,"
			+ "\n"
			+ "\n        	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z : Char, "
			+ "\n        	\" \" : Str,"
			+ "\n        	\"\" : Char, Str -> Str;"
			+ "\n    equations     "
			+ "\n		forall x. (0 \"+\" x) = x,"
			+ "\n    		forall x, y. (succ(x) \"+\" y) = succ((x \"+\" y)),"
			+ "\n    		forall x. (0 \"*\" x) = 0,"
			+ "\n    		forall x, y. (succ(x) \"*\" y) = (x \"+\" (x \"*\" y)),"
			+ "\n"
			+ "\n    		forall x. (0 \"<=\" x) = true,"
			+ "\n    		forall x. (succ(x) \"<=\" 0) = false,"
			+ "\n    		forall x, y. (succ(x) \"<=\" succ(y)) = (x \"<=\" y);"
			+ "\n}"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//figure 3"
			+ "\nS = SCHEMA {"
			+ "\n	entities"
			+ "\n	      Emp, Dept;"
			+ "\n	edges   "
			+ "\n      	mgr : Emp -> Emp,"
			+ "\n          wrk : Emp -> Dept,"
			+ "\n          sec : Dept -> Emp;"
			+ "\n	attributes"
			+ "\n          last@22 : Emp -> Str,"
			+ "\n          name@21 : Dept -> Str,"
			+ "\n          sal@20  : Emp -> Nat;"
			+ "\n	pathEqualities"
			+ "\n		forall e. e.mgr.mgr = e.mgr,"
			+ "\n		forall e. e.mgr.wrk = e.wrk,"
			+ "\n		forall d. d.sec.wrk = d;"
			+ "\n	obsEqualities	"
			+ "\n		forall e. (e.sal \"<=\" e.mgr.sal) = true;"
			+ "\n} : Type"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 5.13"
			+ "\nT = SCHEMA {"
			+ "\n	entities"
			+ "\n	      Emp, Dept, QR;"
			+ "\n	edges   "
			+ "\n      	mgr : Emp -> Emp,"
			+ "\n          wrk : Emp -> Dept,"
			+ "\n          sec : Dept -> Emp,"
			+ "\n          f : QR -> Emp,"
			+ "\n          g : QR -> Dept;"
			+ "\n	attributes"
			+ "\n          last@22 : Emp -> Str,"
			+ "\n          name@21 : Dept -> Str,"
			+ "\n          sal@20  : Emp -> Nat;"
			+ "\n	pathEqualities"
			+ "\n		forall e. e.mgr.mgr = e.mgr,"
			+ "\n		forall e. e.mgr.wrk = e.wrk,"
			+ "\n		forall d. d.sec.wrk = d;"
			+ "\n	obsEqualities	"
			+ "\n		forall e. (e.sal \"<=\" e.mgr.sal) = true,"
			+ "\n		forall q. (q.f.sal \"<=\" q.g.sec.sal) = true,"
			+ "\n		forall q. q.f.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \")))));"
			+ "\n} : Type"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 5.14"
			+ "\nR = SCHEMA {"
			+ "\n	entities"
			+ "\n	      A;"
			+ "\n	edges;"
			+ "\n	attributes"
			+ "\n          emp_last@22 : A -> Str,"
			+ "\n          dept_name@21 : A -> Str,"
			+ "\n          sum@20  : A -> Nat;"
			+ "\n	pathEqualities;"
			+ "\n	obsEqualities;"
			+ "\n} : Type"
			+ "\n"
			+ "\nF = mapping {"
			+ "\n	sorts "
			+ "\n		A -> QR;"
			+ "\n	symbols"
			+ "\n		sum -> forall e. (e.g.sec.sal \"+\" e.f.sal),"
			+ "\n		emp_last -> forall e. e.f.last,"
			+ "\n		dept_name -> forall d. d.g.name;"
			+ "\n} : R -> T "
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//figure 4 (example 6.3)"
			+ "\nJ = INSTANCE {"
			+ "\n      generators "
			+ "\n      	e1, e2, e3, e4, e5, e6, e7 : Emp, "
			+ "\n      	d1, d2, d3 : Dept;"
			+ "\n      equations "
			+ "\n      	d1.name = \"\"(H, \"\"(R, \" \")), "
			+ "\n      	d1.sec = e3, "
			+ "\n      	"
			+ "\n      	d2.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))), "
			+ "\n      	d2.sec = e6,"
			+ "\n      	"
			+ "\n      	d3.name = \"\"(I, \"\"(T, \" \")), "
			+ "\n      	d3.sec = e5,"
			+ "\n      	"
			+ "\n		e1.last = \"\"(G, \"\"(A, \"\"(U, \"\"(S, \"\"(S, \" \"))))),"
			+ "\n		e1.wrk = d3, e1.mgr = e1, "
			+ "\n"
			+ "\n		e2.last = \"\"(N, \"\"(O, \"\"(E, \"\"(T, \"\"(H, \"\"(E, \"\"(R, \" \"))))))),"
			+ "\n		e2.wrk = d2, e2.mgr = e4,"
			+ "\n		"
			+ "\n		e3.last = \"\"(E, \"\"(I, \"\"(N, \"\"(S, \"\"(T, \"\"(E, \"\"(I, \"\"(N, \" \")))))))),"
			+ "\n		e3.wrk = d1, e3.mgr = e3,"
			+ "\n"
			+ "\n		e4.last = \"\"(T, \"\"(U, \"\"(R, \"\"(I, \"\"(N, \"\"(G, \" \")))))),"
			+ "\n		e4.wrk = d2, e4.mgr = e4,"
			+ "\n"
			+ "\n		e5.last = \"\"(N, \"\"(E, \"\"(W, \"\"(T, \"\"(O, \"\"(N, \" \")))))),"
			+ "\n		e5.wrk = d3, e5.mgr = e1,"
			+ "\n"
			+ "\n		e6.last = \"\"(E, \"\"(U, \"\"(C, \"\"(L, \"\"(I, \"\"(D, \" \")))))),"
			+ "\n		e6.wrk = d2, e6.mgr = e7,"
			+ "\n		"
			+ "\n		e7.last = \"\"(H, \"\"(Y, \"\"(P, \"\"(A, \"\"(T, \"\"(I, \"\"(A, \" \"))))))),"
			+ "\n		e7.wrk = d2, e7.mgr = e7,"
			+ "\n"
			+ "\n		e5.sal = 0, e6.sal = 1, e2.sal = 2, e1.sal = 3, e3.sal = 4, e4.sal = 5;"
			+ "\n} : S "
			+ "\n	"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 6.16 / figure 5 "
			+ "\n"
			+ "\nI = INSTANCE {"
			+ "\n	generators "
			+ "\n		e : Emp, d : Dept;"
			+ "\n	equations"
			+ "\n		e.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))),"
			+ "\n		(e.sal \"<=\" d.sec.sal) = true;	"
			+ "\n} : S"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 6.18 "
			+ "\n"
			+ "\nI0 = INSTANCE {"
			+ "\n	generators "
			+ "\n		e0 : Emp;"
			+ "\n	equations"
			+ "\n		e0.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))),"
			+ "\n		(e0.sal \"<=\" e0.wrk.sec.sal) = true;	"
			+ "\n} : S"
			+ "\n"
			+ "\n//these transforms are rejected because the prover cant prove <= is transitive without induction"
			+ "\n/* trans1 = transpres {"
			+ "\n	sorts"
			+ "\n		Emp -> {(e0, e)};"
			+ "\n} : I0 -> I  "
			+ "\n"
			+ "\ntrans2 = transpres {"
			+ "\n	sorts"
			+ "\n		Emp -> {(e0, e.wrk.sec)};"
			+ "\n} : I0 -> I */ "
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 7.7 / figure 6"
			+ "\n"
			+ "\nL = SCHEMA {"
			+ "\n	entities"
			+ "\n	      Emp, Dept, Team;"
			+ "\n	edges   "
			+ "\n      	mgr : Emp -> Emp,"
			+ "\n          wrk : Emp -> Dept,"
			+ "\n          sec : Dept -> Emp,"
			+ "\n          on : Emp -> Team,"
			+ "\n          bel : Team -> Dept; "
			+ "\n	attributes"
			+ "\n          last@22 : Emp -> Str,"
			+ "\n          name@21 : Dept -> Str,"
			+ "\n          sal@20  : Emp -> Nat,"
			+ "\n          col@23 : Team -> Str;"
			+ "\n	pathEqualities"
			+ "\n		forall e. e.mgr.mgr = e.mgr,"
			+ "\n		forall e. e.mgr.wrk = e.wrk,"
			+ "\n		forall d. d.sec.wrk = d,"
			+ "\n		forall e. e.mgr.on = e.on,"
			+ "\n		forall e. e.on.bel = e.wrk;"
			+ "\n	obsEqualities	"
			+ "\n		forall e. (e.sal \"<=\" e.mgr.sal) = true;"
			+ "\n} : Type"
			+ "\n"
			+ "\nH = mapping {"
			+ "\n	sorts"
			+ "\n		Emp -> Emp, "
			+ "\n		Dept -> Dept;"
			+ "\n	symbols"
			+ "\n		sal -> forall e. e.sal,"
			+ "\n		last -> forall e. e.last,"
			+ "\n		name -> forall d. d.name,"
			+ "\n		wrk -> forall e. e.wrk,"
			+ "\n		sec -> forall d. d.sec,"
			+ "\n		mgr -> forall e. e.mgr;"
			+ "\n} : S -> L "
			+ "\n"
			+ "\nSigmaHJ = sigma H J"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 9.3 / 9.5"
			+ "\nQ = query {"
			+ "\n	qA = {for e:Emp, d:Dept;"
			+ "\n		 where e.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))),"
			+ "\n		       (e.sal \"<=\" d.sec.sal) = true;"
			+ "\n		 return emp_last = e.last,"
			+ "\n		 	   dept_name = d.name,"
			+ "\n		 	   sum = (d.sec.sal \"+\" e.sal);"
			+ "\n		 keys;		"
			+ "\n	} : A"
			+ "\n} : S -> R"
			+ "\n"
			+ "\nQJ = apply Q J"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\n//example 9.9"
			+ "\n"
			+ "\nL2 = SCHEMA {"
			+ "\n	entities"
			+ "\n	      A, A0;"
			+ "\n	edges   "
			+ "\n      	f : A0 -> A; "
			+ "\n	attributes"
			+ "\n          last@22 : A0 -> Str,"
			+ "\n          dept_name@21 : A -> Str,"
			+ "\n          sum : A -> Nat;"
			+ "\n	pathEqualities;"
			+ "\n	obsEqualities;"
			+ "\n} : Type"
			+ "\n"
			+ "\nN = query {"
			+ "\n	qA = {for e:Emp, d:Dept;"
			+ "\n		 where e.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))),"
			+ "\n		       (e.sal \"<=\" d.sec.sal) = true;"
			+ "\n		 return dept_name = d.name,"
			+ "\n		 	   sum = (d.sec.sal \"+\" e.sal);"
			+ "\n		 keys;		"
			+ "\n	} : A,"
			+ "\n	qA0 = {for e0:Emp;"
			+ "\n		 where e0.wrk.name = \"\"(A,\"\"(D,\"\"(M,\"\"(I,\"\"(N, \" \"))))),"
			+ "\n		       (e0.sal \"<=\" e0.wrk.sec.sal) = true;"
			+ "\n		 return last = e0.last;"
			+ "\n		 keys f = {e = e0, d = e0.wrk} : qA;"
			+ "\n	} : A0"
			+ "\n} : S -> L2"
			+ "\n"
			+ "\nGammaNJ = apply N J"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////////////////////////////////"
			+ "\n";




}
