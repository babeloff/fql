package catdata.opl.examples;

import catdata.ide.Example;
import catdata.ide.Language;

public class OplIntegrationExample extends Example {

	@Override
	public Language lang() {
		return Language.OPL;
	}
	
	@Override
	public String getName() {
		return "Integration";
	}

	@Override
	public String getText() {
		return s;
	}

	String s = "//Example via Peter Gates"
			+ "\n///////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\nType = theory {"
			+ "\n	sorts"
			+ "\n		dom;"
			+ "\n	symbols"
			+ "\n		xPeter, xPaul, xJane, xPete, xM, xF, "
			+ "\n		xBloodPressure, xBodyWeight, xHeartRate : dom;"
			+ "\n	equations;"
			+ "\n}"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\nS = SCHEMA {"
			+ "\n	entities"
			+ "\n		O, P, T;"
			+ "\n 	edges"
			+ "\n		f: O -> P, "
			+ "\n		g: O -> T;"
			+ "\n	attributes;"
			+ "\n	pathEqualities; "
			+ "\n	obsEqualities;"
			+ "\n} : Type"
			+ "\n"
			+ "\nS1 = SCHEMA {"
			+ "\n	entities "
			+ "\n		Observation, Person, Gender, ObsType;"
			+ "\n	edges "
			+ "\n		f: Observation -> Person, "
			+ "\n		h: Person -> Gender, "
			+ "\n		g: Observation -> ObsType;"
			+ "\n	attributes	"
			+ "\n	     Person_att: Person -> dom, "
			+ "\n	     Gender_att: Gender -> dom, "
			+ "\n	     ObsType_att: ObsType -> dom;"
			+ "\n	pathEqualities; "
			+ "\n	obsEqualities;"
			+ "\n} : Type"
			+ "\n"
			+ "\nS2 = SCHEMA {"
			+ "\n	entities "
			+ "\n		Observation, Patient, Method, Type;"
			+ "\n	edges "
			+ "\n		f: Observation -> Patient, "
			+ "\n		g1: Observation -> Method, "
			+ "\n		g2: Method -> Type;"
			+ "\n	attributes"
			+ "\n         Method_att: Method -> dom,"
			+ "\n	      Patient_att: Patient -> dom, "
			+ "\n	      Type_att: Type -> dom;"
			+ "\n	pathEqualities; "
			+ "\n	obsEqualities;"
			+ "\n} : Type"
			+ "\n"
			+ "\nF1 = mapping {"
			+ "\n	sorts "
			+ "\n		O -> Observation,"
			+ "\n		P -> Person, "
			+ "\n		T -> ObsType;"
			+ "\n	symbols "
			+ "\n		f -> forall x. f(x), "
			+ "\n		g -> forall x. g(x);"
			+ "\n} : S -> S1"
			+ "\n"
			+ "\nF2 = mapping {"
			+ "\n	sorts"
			+ "\n		O -> Observation,"
			+ "\n		P -> Patient,"
			+ "\n		T -> Type;"
			+ "\n	symbols "
			+ "\n		f -> forall x. f(x),"
			+ "\n		g -> forall x. g2(g1(x));"
			+ "\n} : S -> S2"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\nT = SCHEMA {"
			+ "\n	entities "
			+ "\n		O, P, G, T, M;"
			+ "\n	edges "
			+ "\n		f: O -> P, "
			+ "\n		h: P -> G,		"
			+ "\n		g1: O -> M, "
			+ "\n		g2: M -> T;"
			+ "\n	attributes	"
			+ "\n       M_att: M -> dom,"
			+ "\n		G_att: G -> dom,"
			+ "\n		T_att1: T -> dom,"
			+ "\n		T_att2: T -> dom,"
			+ "\n		P_att1: P -> dom,"
			+ "\n		P_att2: P -> dom;"
			+ "\n	pathEqualities; "
			+ "\n	obsEqualities;"
			+ "\n} : Type"
			+ "\n"
			+ "\nG1 = mapping {"
			+ "\n	sorts "
			+ "\n		Observation -> O,"
			+ "\n		Person -> P, "
			+ "\n		ObsType -> T,"
			+ "\n		Gender -> G;"
			+ "\n	symbols "
			+ "\n		f -> forall x. f(x), "
			+ "\n		g -> forall x. g2(g1(x)),"
			+ "\n		h -> forall x. h(x),"
			+ "\n		Person_att -> forall x. P_att1(x),"
			+ "\n		Gender_att -> forall x. G_att(x),"
			+ "\n		ObsType_att -> forall x. T_att1(x);"
			+ "\n} : S1 -> T"
			+ "\n"
			+ "\nG2 = mapping {"
			+ "\n	sorts"
			+ "\n		Observation -> O,"
			+ "\n		Patient -> P,"
			+ "\n		Method -> M,"
			+ "\n		Type -> T;"
			+ "\n	symbols "
			+ "\n		f -> forall x. f(x),"
			+ "\n		g1 -> forall x. g1(x),"
			+ "\n		g2 -> forall x. g2(x),"
			+ "\n       Method_att -> forall x. M_att(x),"
			+ "\n		Patient_att -> forall x. P_att2(x),"
			+ "\n		Type_att -> forall x. T_att2(x); 		"
			+ "\n} : S2 -> T"
			+ "\n"
			+ "\n//this is the pushout schema, but it is easier to work with a schema written by hand (T)"
			+ "\nZ = PUSHOUT F1 F2"
			+ "\n///////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\nI1 = INSTANCE {"
			+ "\n	generators"
			+ "\n		one, two, three : Observation,"
			+ "\n		Peter, Paul : Person,"
			+ "\n	    	M, F :Gender,"
			+ "\n	    	BloodPressure, BodyWeight, HeartRate: ObsType; "
			+ "\n	equations"
			+ "\n		Peter.Person_att = xPeter, Paul.Person_att = xPaul,"
			+ "\n		M.Gender_att = xM, F.Gender_att = xF,"
			+ "\n		BloodPressure.ObsType_att = xBloodPressure, "
			+ "\n		BodyWeight.ObsType_att = xBodyWeight,"
			+ "\n		HeartRate.ObsType_att = xHeartRate,"
			+ "\n		one.f = Peter, two.f = Peter, three.f = Paul,"
			+ "\n		Peter.h = M, Paul.h = M,"
			+ "\n		one.g = BloodPressure, two.g = BodyWeight, three.g = HeartRate;"
			+ "\n} : S1"
			+ "\n"
			+ "\nI2 = INSTANCE {"
			+ "\n	generators"
			+ "\n		o1, o2, o3, o4 : Observation,"
			+ "\n		Pete, Jane : Patient,"
			+ "\n		m1, m2, m3, m4 :Method,"
			+ "\n		BP, Wt : Type;"
			+ "\n	equations"
			+ "\n	     Pete.Patient_att = xPete, Jane.Patient_att = xJane,"
			+ "\n	     BP.Type_att = xBloodPressure, Wt.Type_att = xBodyWeight,"
			+ "\n	     o1.f = Pete, o2.f = Pete, o3.f = Jane, o4.f = Jane,"
			+ "\n	     o1.g1 = m1, o2.g1 = m2, o3.g1 = m3, o4.g1 = m1,"
			+ "\n	     m1.g2 = BP, m2.g2 = BP, m3.g2 = Wt, m4.g2 = Wt;"
			+ "\n} : S2"
			+ "\n"
			+ "\n"
			+ "\nI = INSTANCE {"
			+ "\n	generators "
			+ "\n	  	Peter: P, "
			+ "\n	  	BloodPressure, BodyWeight:T;"
			+ "\n	equations;"
			+ "\n} : S"
			+ "\n"
			+ "\ntemp1 = sigma F1 I"
			+ "\ntemp2 = sigma F2 I"
			+ "\n"
			+ "\na1 = transpres {"
			+ "\n		sorts "
			+ "\n			Person -> {(Peter, Peter)},"
			+ "\n			ObsType -> {(BloodPressure, BloodPressure), (BodyWeight, BodyWeight)};"
			+ "\n} : temp1 -> I1"
			+ "\n"
			+ "\na2 = transpres {"
			+ "\n		sorts"
			+ "\n			Patient -> {(Peter, Pete)},"
			+ "\n			Type -> {(BloodPressure, BP), (BodyWeight, Wt)};"
			+ "\n} : temp2 -> I2"
			+ "\n"
			+ "\n///////////////////////////////////////////////////////////////////////////"
			+ "\n"
			+ "\nb1 = sigma G1 a1"
			+ "\nb2 = sigma G2 a2"
			+ "\n"
			+ "\nanswer = pushout b1 b2"
			+ "\n";


	
}
