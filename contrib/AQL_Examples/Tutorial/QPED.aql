typeside TypeSide = literal {
	java_types
		Varchar = "java.lang.String"
	java_constants
		Varchar = "return input[0]"
}

schema S = literal : TypeSide {
        entities
                QP Person Task Skill PSP TSP
        foreign_keys
                QP_Person : QP -> Person
                QP_Task : QP -> Task
                PSP_Person : PSP -> Person
                PSP_Skill : PSP -> Skill
                TSP_Task : TSP -> Task
                TSP_Skill : TSP -> Skill
        attributes
        		Person_name : Person -> Varchar
        		Skill_name : Skill -> Varchar
        		Task_name : Task -> Varchar   
        		QP_pname : QP -> Varchar
        		QP_tname : QP -> Varchar     
        observation_equations
        		forall qp. qp.QP_pname = qp.QP_Person.Person_name		
        		forall qp. qp.QP_tname = qp.QP_Task.Task_name		
}

instance iS = literal : S {
	generators
	  turing euler shakespeare obama : Person
	  math cs writing politics : Skill
	  govern decide: Task
	  ps1 ps2 ps3 ps4 ps5 ps6 : PSP
	  ts1 ts2 ts3 ts4 : TSP
    equations
	  turing.Person_name = Turing 
	  euler.Person_name = Euler 
	  shakespeare.Person_name = Shakespeare 
	  obama.Person_name = Obama 
	  
	  math.Skill_name = Math 
	  cs.Skill_name = Cs 
	  writing.Skill_name = Writing 
	  politics.Skill_name = Politics
	  
	  govern.Task_name = Govern 
	  decide.Task_name = Decide

      ps1.PSP_Person = turing      ps1.PSP_Skill = cs
      ps2.PSP_Person = turing      ps2.PSP_Skill = math
      ps3.PSP_Person = euler       ps3.PSP_Skill = math
      ps4.PSP_Person = euler       ps4.PSP_Skill = politics
      ps5.PSP_Person = shakespeare ps5.PSP_Skill = writing
      ps6.PSP_Person = obama       ps6.PSP_Skill = politics

	  ts1.TSP_Task = govern ts1.TSP_Skill = writing	
	  ts2.TSP_Task = govern ts2.TSP_Skill = politics	

	  ts3.TSP_Task = decide ts3.TSP_Skill = math	
	  ts4.TSP_Task = decide ts4.TSP_Skill = cs	
}

constraints phi = literal : S {
	forall
   		qp:QP  
   		ts:TSP
	where
   		TSP_Task(ts) = QP_Task(qp)
 ->   		
	exists
   		ps:PSP
	where
   		PSP_Person(ps) = QP_Person(qp) 
   		PSP_Skill(ps) = TSP_Skill(ts)
}

/*
 * { qp:QP | forall tsp:TSP where qp.task = tsp.task ->
 *           exists psp:PSP where qp.person = psp.person /\ psp.skill = tsp.skill } 
 */
/*
 forall tsp:TSP ->
 exists psp:PSP qp:QP where qp.person = psp.person /\ psp.skill = tsp.skill /\ qp.task = tsp.task } 
*/

instance front = literal : S {
	generators
   		qp:QP  
   		ts:TSP   		
	equations
   		TSP_Task(ts) = QP_Task(qp)
}

instance back = literal : S {
	generators
   		qp:QP  
   		ts:TSP
	   	ps:PSP
	equations
   		PSP_Person(ps) = QP_Person(qp) 
   		PSP_Skill(ps) = TSP_Skill(ts)
   		TSP_Task(ts) = QP_Task(qp)
}

transform phi0 = literal : front -> back {
	generators
		qp -> qp
		ts -> ts
}

instance ryansGuess = literal : S {
	imports
		iS
	generators
		qp : QP
	equations
		qp.QP_Task = govern		
}

constraints take2 = literal : S {
 imports phi
	
	forall 
		tsp:TSP 
		psp:PSP
	where
		psp.PSP_Skill = tsp.TSP_Skill 
 ->
 	exists  
 		qp:QP 
 	where 
 		qp.QP_Person = psp.PSP_Person
 		qp.QP_Task = tsp.TSP_Task  
}

instance iQP = chase take2 iS 3
