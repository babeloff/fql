typeside TypeSide = literal {
	java_types
		Varchar = "java.lang.String"
	java_constants
		Varchar = "return input[0]"
   //options
   //  require_consistency=false
}
/* The EDs for:
 *   1. Declaring a table to be nonempty
 *   2. Declaring a table to have at most one row
 *   3. Declaring a foreign key to be surjective
 *   4. Declaring a foreign key to be injective
 * 
 *  are all illustrated using the following schema. */
schema s1 = literal : TypeSide {
	entities
	  A B
	foreign_keys
	  f : A -> B
	attributes
	  Aatt : A -> Varchar
	  Batt : B -> Varchar
   //options
   //  require_consistency=false
}

/* Here we create an instance of s1 whose entity A is empty to illustrate the results of
 * running the chase on the nonempty constraint for A.
 */
instance i1 = literal : s1 {
	generators
	  b1 b2 : B
	multi_equations
	  Batt -> {b1 Rowb1, b2 Rowb2}
}
// The A nonempty ED.
constraints nonempty = literal : s1 {
 ->   		
	exists
   		a:A
}
// Corresponding frozen instances.
// The front has no generators due to the empty forall clause.
instance frontne = literal : s1 {
}
// The back has the single genertor from the exists clause.
instance backne = literal : s1 {
	generators
   		a:A
}
// Transform between frozen instances.
// Since there is an empty front the transform is empty.
transform phine = literal : frontne -> backne {
}
// Run the chase on the nonempty constraint applied to the instance i1. The integer 2 indicates
// the number of passes the chase should be run.
instance ine = chase nonempty i1 2

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

// Here is we create an instance of s1 whose entity A has more than one row to illustrate the results
// of running the chase on the "at most one row" constraint for A.  
instance i2 = literal : s1 {
	generators
	  b1 b2 : B
	  a1 a2 : A
	multi_equations
	  f -> {a1 b1, a2 b1} // This works
	  //f -> {a1 b1, a2 b2} //This throws a warning
	  Batt -> {b1 Rowb1, b2 Rowb2}
	 //Aatt -> {a1 Rowa1, a2 Rowa2} //This throws a similar error/warning --see below after the chase--
}
// The at most one row ED.
constraints atMostOne = literal : s1 {
	forall
	  a1 a2 : A 
 ->   		
	where
   	  a1 = a2
}

// Corresponding frozen instances.
// The front contains the two generators in the forall clause.
instance frontamo = literal : s1 {
	generators
	  a1 a2 : A
}

// The back contains the two generators of the forall clause and the equation from the second where clause.
instance backamo = literal : s1 {
	generators
   	   a1 a2 : A
    equations
       a1 = a2
}
// Transform between frozen instances.
transform phiamo = literal : frontamo -> backamo {
	generators
	   a1 -> a1
	   a2 -> a2
}

instance iamo = chase atMostOne i2 2
/* This warning is generated by un-commenting the following row in i2:  
 *  Aatt -> {a1 Rowa1, a2 Rowa2}
 *  
 * Error in instance inmto: Not necessarily consistent.  This isn't necessarily an error, 
 * but is unusual.  Set require_consistency=false to proceed.  Type algebra is
 * 
 * functions
 * 
 * foreign keys
 * 
 * attributes
 * 
 * generating entities
 * 
 * generating nulls
 * 
 * equations
 *     Rowa1 = Rowa2
 * 
 * Similarly this warning is generated by exchanging the following rows in i2:
 * 	  //f -> {a1 b1, a2 b1} // This works  
 * 	  f -> {a1 b1, a2 b2} //This throws a warning
 * 	  
 * Error in instance iamo: Not necessarily consistent.  This isn't necessarily an error,
 * but is unusual.  Set require_consistency=false to proceed.  Type algebra is
 * 
 * functions
 * 
 * foreign keys
 * 
 * attributes
 * 
 * generating entities
 * 
 * generating nulls
 *  inr (id0, Aatt) : Varchar
 *  
 * equations
 * 	Rowb2 = Rowb1
 */

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

/* Here we create an instance i3 of s1 whose foreign key f : A -> B has a row b2 in B with no inverse
 * image in A to illustrate the results of running the chase on the surjective constraint on f.
 */
instance i3 = literal : s1 {
	generators
	  b1 b2 : B
	  a1 a2 : A
	multi_equations
	  f -> {a1 b1, a2 b1}
	  Batt -> {b1 Rowb1, b2 Rowb2}
	  Aatt -> {a1 Rowa1, a2 Rowa2}
}

// The surjective constraint
constraints srj = literal : s1 {
   forall
     b : B
   ->
   exists
     a : A
   where 
     f(a) = b
}
// The front 
instance frontSrj = literal : s1 {
	generators
	  b : B
}

instance backSrj = literal : s1 {
	generators
	  a : A
	  b : B
	equations
	  f(a) = b
}

transform tSrj = literal : frontSrj -> backSrj {
	generators
	  b -> b
}

instance iSrj = chase srj i3 2

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

/* We again make use of instance i3 of s1 whose foreign key f : A -> B has two rows a1 and a2 with b1 as image
 * in B to illustrate the results of running the chase on the injective constraint on foreign key f.
 */

// The injective constraint
constraints inj = literal : s1 {
   forall
     a1 a2 : A
   where
     f(a1) = f(a2)
   ->
   where 
     a1 = a2
}

instance i4 = literal : s1 {
	generators
	  b1 b2 : BS
	  a1 a2 a3: A
	multi_equations
	  f -> {a1 b1, a2 b2}
	  Batt -> {b1 Rowb1, b2 Rowb2}
	  Aatt -> {a1 Rowa1, a2 Rowa2}
}



instance iInj = chase inj i4 2

