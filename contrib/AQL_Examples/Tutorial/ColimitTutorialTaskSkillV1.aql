/***************************************************************************************************
 * This file is the first of a sequence of files whose purpose is to illustrate the use of AQL to
 * construct a sequence of models of increasing complexity. As we proceed we will draw analogies
 * to relational constructions that may be more familiar to practicing database engineers.  
 * 
 * The structural element that forms the foundation of relational algebra is the relvar. A relvar is
 * a mathematical definition that roughly corresponds to the structure of a single table. Commercial
 * implementations of relvars are table definitions based on a set of fixed types provided by the 
 * relational database management system (RDBMS) that define the domain over which each column of 
 * the table is allowed to vary. Having defined one or more table structures, constraints can be
 * added to further restrict the values over which a particular column may vary. 
 * 
 * In contrast, AQL provides a declarative structure that allows the user to define an algebraic
 * definition of the type side. In its current implementation AQL defines this algebra by wrapping
 * a selection of Java types and functions. In this sequence of files we will restrict the type side
 * to a simple nonempty type side consisting of a string. This will allow us to label records in a 
 * way that will provide human readable output associated with the sequence of models we produce.
 *
 * The type side defines a foundation that can then be extended to define a schema. Notice that in  
 * contrast with relational algebra there is no notion of an entity or relvar in isolation. The
 * closest analog to a relvar in AQL is a schema with a single entity. With that in mind we proceed
 * by creating a sequence of schemas, each with a single entity.
 ***************************************************************************************************

 * Simple type side that creates a string type compatible with MySQL Varchar. */
typeside TypeSide = literal {
	java_types
		Varchar = "java.lang.String"
	java_constants
		Varchar = "return input[0]"
}

/* As mentioned above the schema is declared as an extension of the typeside. The first schema we
 * create is minimal in that it contains a single entity skill with a single attribute that allows
 * us to label a skill. AQL contains a variety of higher order types that build on previously
 * defined types. By convention we prefix the schema name with the letter "s" to aid the user in
 * remaining oriented when reading type constructions that depend on the schema type. 
 * 
 * By clicking on the run button AQL will construct a runtime viewing window that has a list of each
 * of the constructions created in this model in a pane on the left hand side of the window. A view
 * each construction is available by clicking on the construction of interest.
 */
schema sS = literal : TypeSide {
	entities
		Skill
	attributes
		SName : Skill -> Varchar
}

// Schema with the single entity Task.
schema sT = literal : TypeSide {
	entities
		Task
	attributes
		TName : Task -> Varchar
}

/* As schemas extend the type side so instances extend schemas. An AQL instance consists of a set of
 * generators for each entity in the schema. The user can optionally create equational definitions
 * which associate attribute values with each generator. In the absence of such an association AQL
 * will create what is called a labeled null. Labeled nulls are essential for creating a structure
 * that can be formally defined and verified as consistent. Notice that labeled nulls are very
 * different than nulls in currently available RDBMSs.
 * 
 * A labeled null is strongly typed, hence the qualifier "labeled". Every null in AQL is typed by
 * its associated generator and attribute. For example in the instance definition below if the
 * association of the generator s0 with the string "Math" were missing AQL would create a null value
 * that would be typed by the pair (s0, SName).
 * 
 * Representative instance of skills. Running this file and selecting an instance below will display
 * a tabular representation of each instance. */
instance iSkl = literal : sS {
	generators
	    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill
	multi_equations
	    SName -> {s0 Math, s1 CompSci, s2 DBA, s3 Pharma, s4 Programming, s5 Teaching, 
	    		  s6 GrantWriting, s7 Finance, s8 Management, s9 PaperWriting}
}

/* Similarly to the skills instance above we create a representative instance of tasks. */
instance iTsk = literal : sT {
	generators
	    t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 : Task
	multi_equations
	    TName -> {t1 LaunchCIStartup, t2 BuildSWProduct, t3 WriteTutorial, t4 BuildPhrmColim, t5 BuildFncColim,
	              t6 WriteMathPaper, t7 TeachMath, t8 TeachCS, t9 RunPhrmIntProject, t10 RunFincIntProject}
}

/* Now we create a slightly more interesting schema. This schema still consists of only one entity,
 * but that entity now has a pair of attributes. */
schema sSnT = literal : TypeSide {
	entities
	  SkillNeededForTask
	attributes
	  skill : SkillNeededForTask -> Varchar
	  task : SkillNeededForTask -> Varchar
}

/* The definition of an entity with a pair of attributes provides us with the ability to create an
 * instance that associates each such pair with the same generator. Here will illustrate this idea
 * with such a representative instance. */
instance iSnT = literal : sSnT {
	generators
		st1 st2 st3 st4 st5 st6 st7 st8 st9 st10
		st11 st12 st13 st14 st15 st16 st17 st18 st19 st20
		st21 st22 : SkillNeededForTask
	multi_equations
		skill -> {st1 CompSci,         st2 Programming,     st3 GrantWriting,    st4 PaperWriting,
				  st5 CompSci,         st6 Programming,     st7 Management,
				  st8 Programming,     st9 Teaching,        st10 PaperWriting,
				  st11 Pharma,         st12 Programming,
				  st13 Finance,        st14 Programming,
				  st15 Math,           st16 PaperWriting,
				  st17 Math,           st18 Teaching,
				  st19 Pharma,         st20 Management,
				  st21 Finance,        st22 Management}
		task ->  {st1 LaunchCIStartup, st2 LaunchCIStartup, st3 LaunchCIStartup, st4 LaunchCIStartup,
				  st5 BuildSWProduct,  st6 BuildSWProduct,  st7 BuildSWProduct,
				  st8 WriteTutorial,   st9 WriteTutorial,   st10 WriteTutorial,
				  st11 BuildPhrmColim, st12 BuildPhrmColim,
				  st13 BuildFncColim,  st14 BuildFncColim,
				  st15 WriteMathPaper, st16 WriteMathPaper,
				  st17 TeachMath,      st18 TeachMath,
				  st19 RunPhrmProject, st20 RunPhrmProject,
				  st21 RunFncProject,  st22 RunFncProject}
}

/* Next we introduce an AQL feature that allows us to assemble multiple source schemas into a single
 * target schema. This construction is called a schema colimit by virtue of its mathematical origins
 * in category theory. In its full generality this construction can become fairly involved so we 
 * begin with a degenerate case that is analogous to what is sometimes called landing tables from 
 * source schemas into a single schema where data transforms can be conveniently developed.
 * 
 * In this particular case we "land" the three single table schemas sT, sS, sSnT into a single 
 * structure S_T_SnT_SumAuto whose type is schema_colimit. Behind the scenes a schema_colimit
 * includes a variety of structures we will describe in a moment. */
schema_colimit S_T_SnT_SumAuto = quotient sT + sS + sSnT: TypeSide {}

/* The automatically generated schema colimit prefixes each object within the target schema with the
 * label associated with the source schema from which that object originated. With the modify
 * command we have the option of providing more concise names where no disambiguation is required. */
schema_colimit S_T_SnT_Sum = modify S_T_SnT_SumAuto {
	rename entities
		sS_Skill -> Skill
		sT_Task -> Task
		sSnT_SkillNeededForTask -> SkillNeededForTask
	rename attributes
		sS_SName -> SName
		sT_TName -> TName
	    sSnT_skill -> skill
	    sSnT_task -> task
}

/* With this sequence of constructions we reveal the inner structure of the schema colimit. This
 * consists of a target schema and a schema mapping from each source schema to that target.
 * 
 * In so doing we have introduced another AQL construction with no formal analogy in relational
 * algebra, a schema mapping. Schema mappings are generally formal structures that provide a means
 * of defining an arrow from one schema to another. Such an arrow can be thought of as a higher
 * order function which takes a source schema as input and produces a target schema as output. AQL
 * provides machinery for both indirectly (as below) and directly defining such mappings. That
 * machinery guarantees that the structure of the source schema is faithfully preserved as it is
 * mapped to the target schema. */
schema sS_T_SnT_Sum = getSchema S_T_SnT_Sum
mapping mSkillToS_T_SnT_Sum = getMapping S_T_SnT_Sum sS
mapping mTaskToS_T_Snt_Sum = getMapping S_T_SnT_Sum sT
mapping mSkillNeededForTaskToS_T_SnT_Sum = getMapping S_T_SnT_Sum sSnT

/* AQL provides a convenient shortcut to the construction of an instance for the colimit referenced
 * by the keyword coproduct_sigma. Without going into the details for now, in this degenerate case
 * the effect of this construction is to create an instance of the schema associated with the
 * colimit that independently adds each of the representative instances above for each single entity 
 * associated with the three source schemas. It accomplishes this by pushing each of those instances
 * through the structure preserving maps created by the colimit construction. */
instance iS_T_SnT_Sum = coproduct_sigma
   mSkillToS_T_SnT_Sum iSkl
   mTaskToS_T_Snt_Sum iTsk
   mSkillNeededForTaskToS_T_SnT_Sum iSnT
   : sS_T_SnT_Sum

/* In the next step of this modeling sequence we introduce another AQL construction. This
 * construction is referenced using the query keyword. As you might expect this construction is
 * related to the SQL notion of a query. This is the case, but in the style of AQL a query is
 * an extension of the notion of a structure preserving map. As such, like the mappings described
 * above in connection with the colimit construction, a query is a structure preserving map between
 * schemas. This means that in order to define a query one must have in place the definition of a
 * source schema and a target schema.
 * 
 * In the current context we have as source schema the result of the colimit construction. If you
 * run this file and look at the colimit schema sS_T_SnT_Sum and associated instance you will
 * discover the we have created a schema consisting of three independent tables without any
 * associated constraints relating one table to another. We now use the query construction to
 * introduce such constraints in a way that is analogous to the addition of the foreign key
 * constraints supported in RDBMSs.
 * 
 * We now set up the query construction by defining the desired target schema. This schema is
 * identical to the output of the colimit construction but with the addition of a pair of foreign
 * keys from the entity with (skill, task) attribute pair to the skill and task entities
 * respectively. This produces a schema which is known in category theory as a span and it can be
 * summarized as follows:
 *
 *          fk_SnT_S             fk_SnT_T
 *     Skill <----- SkillNdFrTask -----> Task
 *     
 * Notice there is an additional feature in this schema declaration not available in relational
 * algebra. This is the observation equations block. AQL has the ability to define equations that
 * are associated with paths defined by arrows. In this case the first of the two declarations below 
 * can be visualized as path equations as follows.
 * 
 *           Skill  ---------
 *            /\             \ SName
 *  fk_SnT_S  |               \
 *           |      skill     \/
 *    SkillNdFrTask -----> Varchar
 *    
 * This means that the value of the attribute skill attribute on SkillNdFrTask is guarenteed to be
 * the same value you will get by following the foreign key fk_SnT_S through Skill to the SName
 * attribute, that is the high road gives the same answer as the low road. In a relational schema
 * this is known as denormalization and is generally regarded as bad practice as guarantees of the
 * equality of such attributes requires the overhead of triggers that verify such equalities for
 * each transaction. AQL on the other hand verifies this as part of its type checking at design
 * time. */
schema sSTSpn = literal : TypeSide {
	entities
	  Skill Task
	  SkillNdFrTask
	foreign_keys
	  fk_SnT_S   : SkillNdFrTask -> Skill
	  fk_SnT_T   : SkillNdFrTask -> Task
	attributes
	  SName  : Skill -> Varchar
	  TName  : Task -> Varchar
	  skill  : SkillNdFrTask -> Varchar
	  task   : SkillNdFrTask -> Varchar
	observation_equations
	  forall snt. snt.fk_SnT_S.SName = snt.skill
	  forall snt. snt.fk_SnT_T.TName = snt.task
}

/* As mentioned earler in connection with structure preserving maps a query by extension can be
 * thought of as a higher order function that maps one schema onto another in such a way that it
 * preserves the structure of the source schema in the structure of the target schema. Queries have
 * additional features that provide functionality analogous to that found in SQL queries. To see
 * this we will deconstruct the query below as follows.
 * 
 * The query syntax has two blocks, the entities block and the foreign keys block. The foreign keys
 * block has no analog in SQL as foreign keys are structures that are added to tables and are not
 * a part of structured query language.
 * 
 * The entities block on the other hand does have a close analogy to SQL. Within the entities block
 * there is a sub-block for each entity of the target schema. Remember that the output of a SQL
 * query is a single table or relation. The structure of an entity block closely resembles that of
 * a SQL query. The from clause corresponds to the from clause of SQL. Similarly, the where clause 
 * corresponds to the where clause of SQL. The return block corresponds to the select clause of
 * SQL.
 * 
 * The specific AQL syntax does differ from SQL so a few words about that. The from clause consists
 * of a set of variables typed by entities using the ":" character. These variables can be thought
 * of as generator variables that vary over the generators of the entities of the source schema. By
 * convention we label them in a way that is unique across all blocks as they will later be
 * referenced in the foreign keys block. Assignment is indicated with the two characters "->" that
 * visually represent an arrow. This is used at the level of the sub-block as a whole and in the
 * return clause. In the return clause the value of a target attribute on the left hand side of an
 * assignment is given by a variable of the from clause followed by a valid path. Finally, in direct
 * analogy with SQL, any filtering or joins are indicated using a sequence of equations that are
 * implicitly connected by logical ands. Notice that this means that AQL queries as currently
 * defined are limited to conjunctive queries.
 * 
 * As an aside it is possible to extend AQL queries to include logical ors through the introduction  
 * of boolean functions on the type side. For now this is not yet supported due to the theorem
 * proving burden.
 *
 * As in the cases above this particular query is somewhat degenerate in that two of the entity
 * sub-blocks below are direct mappings from source to target, that is, Skill and Task. In each of
 * these sub-blocks the records of the source entity are copied into the target entity (each having
 * the same name in this degenerate case).
 * 
 * The interesting sub-block is the one associated with SkillNdFrTask. Notice that the target entity
 * SkillNdFrTask requires records from all three source entities. The way in which the target
 * records are assembled is through a pair of joins indicated by the pair equations in the where
 * clause.
 * 
 * Now we return to the foreign keys clause. Each foreign key is an arrow defining a functional
 * dependency from a source table to a target table. As such we must specify how a representative 
 * generator that is passed as an argument to this function is assigned to a generator in the
 * target. Let's consider a specific example:
 * 
 * 		// fk_SnT_S   : SkillNdFrTask -> Skill
 *		fk_SnT_S   -> {ss -> sn}
 *
 * In this case the foreign key fk_SnT_S takes as input a generator from SkillNdFrTask and must
 * assign it to a skill generator. This means we need to get a skill generator and place it in the
 * foreign key column of the SkillNdFrTask table. To do this we need to establish a mapping between
 * the generator of the Skill entity sub-block to the Skill entity in the SkillNdFrTask sub-block.
 * Notice this is contravariant or opposite to the direction of the function arrow of the foreign 
 * key.
 */
query qS_T_SnT_SumToSTSpn = literal : sS_T_SnT_Sum -> sSTSpn {
	entities //source entities: Skill SkillNeededForTask Task
		Skill -> {
			from
				ss : Skill
			return
				SName -> ss.SName
		}
		SkillNdFrTask -> {
			from
				snt : SkillNeededForTask
				sn  : Skill
				nt  : Task
			where
				snt.skill = sn.SName
				snt.task = nt.TName
			return
				skill -> snt.skill
				task  -> snt.task
		}
		Task -> {
			from
				tt : Task
			return
				TName -> tt.TName
		}
	foreign_keys
		// fk_SnT_S   : SkillNdFrTask -> Skill
		fk_SnT_S   -> {ss -> sn}
		// fk_SnT_T   : SkillNdFrTask -> Task
		fk_SnT_T   -> {tt -> nt}
}

/* Pushing the instance generated by the coproduct sigma construction through the query above
 * produces an instance reflecting the foreign keys introduced in the target schema we set up as
 * part of the query definition. */
instance iSTSpn = eval qS_T_SnT_SumToSTSpn iS_T_SnT_Sum

/* We export the instance iSTSpn to MySQL for use in later stages of this tutorial.
 * First clean out the target tables if present from a previous run. */
pragma pCleanUp = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"DROP TABLE IF EXISTS sts_SkillNdFrTask"
"DROP TABLE IF EXISTS sts_Skill"
"DROP TABLE IF EXISTS sts_Task"}

// Export the results of the above construction of the span and its representative instance.
pragma eSTS = export_jdbc_instance iSTSpn "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" "sts_"
  { options varchar_length = 256 }

// Display the contents of the ci_test schema in MySQL
pragma pp2 = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"SHOW  TABLES"}


// Bring the exported instance back in for round trip (export iSTSpan import iSTSpnImp) comparison.
instance iSTSpnImp = import_jdbc "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" : sSTSpn {
   // entities - create generators for each entity based on the primary key of each entity in the source database
   Skill -> "select id from sts_Skill"
   Task -> "select id from sts_Task"
   SkillNdFrTask -> "select id from sts_SkillNdFrTask"
   // foreign keys
   fk_SnT_S -> "select id, fk_SnT_S from sts_SkillNdFrTask"
   fk_SnT_T -> "select id, fk_SnT_T from sts_SkillNdFrTask"
   // attributes
   SName -> "select id, SName from sts_Skill"
   TName -> "select id, TName from sts_Task"
   skill -> "select id, skill from sts_SkillNdFrTask"
   task -> "select id, task from sts_SkillNdFrTask"
}

