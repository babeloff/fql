/***************************************************************************************************
 *                                                                                                 *
 *                                         AQL Tutorial                                            *
 *                                  Tasks <-> Skills <-> People                                    *
 *                                                                                                 *
 ***************************************************************************************************
 *                                         Introduction                                             
 *                                                                                                  
 * This file contains a sequence of models intended to illustrate the use of Algebraic Query
 * Language (AQL) to formalize database concepts in a mathematically verifiable way. Each AQL file 
 * in this sequence will build on previous ideas, introducing AQL features in the context of
 * conceptual models relating skills to tasks and people.
 *																									
 * The following is a brief outline of the sequence of models and what the reader should take away	
 * from reviewing each model in the sequence.														
 * 																									
 * This file introduces a series of AQL constructions and compares those constructions with
 * analogous relational constructions where appropriate. We begin with a set of independent schemas
 * and produce a single schema that is an an integrated assembly of the three source schemas. Along
 * the way we will see some basic AQL constructions to include:
 *     
 *       1) typeside -- User defined construction for customization of data types.
 *      
 *       2) schema -- Extends the type side to define objects of kind schema.
 *       
 *       3) category -- Polymorphic abstraction that unifies many AQL concepts and constructions. 
 *       
 *       4) schema as category -- Schemas interpreted through the abstract lens of categories.
 *       
 *       5) instance -- Extends the schema kind. Instance kinds can be thought of as the data that 
 *          "fills" the schema.
 *          
 *       6) instance as category -- Instances interpreted through the abstract lens of categories.
 *       
 *       7) transform -- map from one instance to another of the same schema.
 *       
 *       8) the category of instances of a schema -- Instance kinds all typed by the same schema
 *          related by transforms as arrows.
 *          
 *       9) instance coproduct -- Universal construction that "adds" multiple instances associated 
 *          with a schema. 
 *          
 *      10) instance coequalizer -- Universal construction that uses a linking instance and a pair
 *          of transforms to merge records records within an instance.
 *          
 *      11) schema mappings, queries and the category of schemas -- Schema mappings define the
 *          arrows in the category of schemas. Queries generalize schema mappings and provide 
 *          functionality similar to SQL queries.
 *          
 *      12) schema colimits -- A kind that unifies coproducts and coequalizers but in the context of
 *          the category of schemas rather than the category of instances of a schema. Generally
 *          formalizes a diagram of schemas connected by mappings that can be used to assemble
 *          source schemas into a single target schemas.
 *          
 *      13) category of the category of instances of a schema -- The category where all the action
 *          is. We might call this the enterprise category (EC). This is where we tackle problems 
 *          that involve moving data between schemas and the larger problem of bringing multiple 
 *          source schemas together and integrating them.
 *      
 *      13) sigma --| delta --| pi -- Arrows in EC. The machinery AQL uses to move data around the 
 *          enterprise. These arrows are the building blocks of the eval construction that moves 
 *          data through AQL queries.
 *      	
 *************************************************************************************************** 
 *****I will add additional items as I complete the merging of the other files into this file.******
 ***************************************************************************************************
 * As we proceed we will draw analogies to relational constructions that may be more familiar to
 * practicing database engineers. We open with a brief review of the essential features of
 * relational algebra as they are related to AQL features.
 * 
 * The structural element that forms the foundation of relational algebra is the relvar. A relvar is
 * a mathematical definition that roughly corresponds to the structure of a single table. Commercial
 * implementations of relvars are table definitions based on a set of fixed types provided by the 
 * relational database management system (RDBMS) that define the domain over which each column of 
 * the table is allowed to vary. Having defined one or more table structures, constraints can be
 * added to further restrict the values over which a particular column may vary. 
 * 
 * In contrast, AQL provides a declarative structure that allows the user to define an algebraic
 * definition of the type side. In its current implementation AQL defines this algebra by wrapping
 * a selection of Java types and functions. In this sequence of files we will restrict the type side
 * to a string type compatible with a MySQL Varchar. This will allow us to label records in a way
 * that will provide human readable output associated with the sequence of models we produce.
 *
 * AQL models always begin with a type side declaration. The type side defines a foundation that can 
 * then be extended to define schemas.
 ***************************************************************************************************

 ***************************************************************************************************
 *                                         Type Sides
 *
 * Type sides are an AQL construction that provides the possibility of introducing programming
 * language features that can be used to enhance the power of a database. These features are roughly 
 * analogous to stored functions that can be invoked inline within an SQL statement. To illustrate
 * how this capability works we will create a type side that exposes a string type which we label
 * Varchar in anticipation of later integration with an external RDBMS. To this we add the Java
 * string matches method to illustrate how Java functions can be exposed to the AQL framework. For
 * more details we refer the reader to the examples available by selecting the dropdown in the upper
 * right hand corner of the application. Specifically, the AQL Tutorial example.
 ***************************************************************************************************/
typeside TypeSide = literal {
	java_types
		Varchar = "java.lang.String"
		Bool = "java.lang.Boolean"
	java_constants
		Varchar = "return input[0]"
		Bool = "return java.lang.Boolean.parseBoolean(input[0])"
	java_functions
		true : Bool = "return true"
		Matches : Varchar, Varchar -> Bool = "return input[0].matches(input[1])"
}

/***************************************************************************************************
 *                                          	Schemas
 * 
 * As mentioned above the schema is declared as an extension of the type side. Notice that in
 * contrast with relational algebra there is no notion of an entity or relvar in isolation. The
 * closest analog to a relvar in AQL is a schema with a single entity. With that in mind we proceed
 * by creating a sequence of schemas, each with a single entity.
 * 
 * The first schema we create is minimal in that it contains a single entity Task with a single
 * attribute that allows us to label a task. AQL contains a variety of constructions that build on 
 * on previously defined types. Following the programming language literature we will refer to such
 * constructions as kinds. By convention we prefix the schema name with the letter "s" to remind the
 * reader when that name is encountered in the construction of a dependent kind that the object is 
 * of kind schema. 
 * 
 * By clicking on the run button AQL will construct a runtime viewing window that has a list of each
 * of the constructions created in this model in a pane on the left hand side of the window. A view
 * of each construction is available by clicking on the construction of interest in the left hand
 * pane.
 * 
 * Similarly this editor has a pane on the right hand side containing an outline of the
 * constructions contained in this file. One can navigate to a construction by clicking on that
 * construction in the outline.
 ***************************************************************************************************/
schema sT = literal : TypeSide {
	entities
		Task
	attributes
		TName : Task -> Varchar
}

/* Now we create a slightly more interesting schema. This schema still consists of only one entity,
 * but that entity now has a pair of attributes. */
schema sSnT = literal : TypeSide {
	entities
	  SkillNeededForTask
	attributes
	  skill : SkillNeededForTask -> Varchar
	  task : SkillNeededForTask -> Varchar
}

/*************************************************************************************************** 
 *                                     Categories Introduced                                       *
 *                                     Schemas as Categories                                       *
 * *************************************************************************************************
 * The third schema we introduce has two entities, Skill and SkillClass that define a simple two
 * level taxonomy for skills. This brings into play additional blocks as part of the declarative
 * structure of a schema. First the foreign_keys block. In AQL, schemas as first class objects come
 * equipped with all of the machinery for defining a schema as a kind. This includes declaration of
 * dependencies between entities. These dependencies are given the name foreign key so as to be
 * consistent with relational nomenclature.
 * 
 * Finally we have a third block that has no analog in SQL systems, the observation_equations block.
 * To understand this block we must take time for a brief digression to introduce the abstract 
 * notion of a category. 
 * 
 * AQL is motivated by a branch of mathematics known as category theory. The reader who is
 * interested in systematic development of category theory should refer to any one of a number of
 * excellent introductions. Here are several such references:
 * 
 * Category Theory by Steve Awodey
 * 
 * Category Theory for Computing Science by Michael Barr and Charles Wells
 * 
 * Category Theory for the Sciences By David Spivak
 *  
 * Conceptual Mathematics: A first introduction to categories by F.William Lawverer and Stephen H.
 * Schanuel.
 * 
 * Here we intuitively describe categories and identify specific concrete examples as they relate to
 * AQL. A category consists of a set of objects connected by arrows. As such it is related to a
 * directed graph where the objects are nodes and arrows are edges with direction indicated by their     
 * associated arrow. In addition to the properties of a directed graph each object of a category
 * is required to have a distinguished arrow that identifies that object and whose source and target 
 * are equal to the object it identifies.
 * 
 * Let's consider the three schemas we have so far constructed, but with an empty type side (i.e. no
 * attributes). Each could be viewed as an abstract category where the set of objects is the set of
 * entities. Hence schemas are the first example of an AQL construction that can be interpreted as
 * a category.
 * 
 * With this in mind sT and sSnT are both one object categories. By virtue of the fact that the set 
 * of identity arrows and the set of objects are essentially the same set (technically isomorphic
 * to each other) we can unambiguously refer to each identity arrow using the same label as its
 * corresponding entity. Similarly sS (again neglecting attributes) is a two object category with
 * one non-identity arrow, the foreign key fk_HasClass. This category is sometimes called the arrow
 * category. In future examples we will see that more generally schemas with empty type sides are
 * not strictly speaking categories, but rather presentations of categories. This means they have
 * all the information necessary to generate a category through a process known as saturation.
 * 
 * Abstract categories are by design devoid of attachments to any specific context. In order to
 * leverage the context free nature of category theory we need a mechanism by which we can anchor
 * a category into a computational environment. Functional programming languages such as Haskell
 * provide one strategy for doing this. AQL provides another strategy that is motivated by the
 * capabilities of modern database management systems, so AQL extends the basic notion of an
 * abstract category with a type side. We will rely on the above intuitive motivation and will not
 * formally develop this idea here. The interested reader is referred to the research paper upon 
 * which the AQL implementation is based:
 * 
 * https://arxiv.org/abs/1602.03501.
 * 
 * There is an additional feature of categories that is critical to this discussion and that lies
 * at the heart of the expressive power of category theory. This the notion of a path. A category
 * by definition automatically contains all paths that can be generated by composing arrows head to 
 * tail. This process of generating all paths implied by arrow composition is the aforementioned 
 * saturation.
 * 
 * The order in which one chooses to compose arrows has no effect on the result so AQL provides a
 * convenient syntax for indicating a path using the dot notation (elaborated below). Having added
 * additional arrows for each path we now have the ability to declare two paths that begin and end 
 * on the same object to be equal and so the declarative structure of a category includes equations.
 * 
 * Path equations can be used to complete an intuitive explanation of the properties of identity 
 * arrows. Any path that includes an identity arrow is equal to the path obtained when that identity 
 * arrow is omitted. Considering arrow composition as analogous to addition we can think of identity
 * arrows as analogous to zero, but rather than having one zero we have one for each object in the
 * category. Category theorists make this analogy by saying that identity arrows are paths of length
 * zero. To further strengthen this analogy it can be shown that the counting numbers under the
 * binary operation of addition define a one object category. Each arrow of the category is a
 * counting number. Zero is the identity arrow. Addition is arrow composition.
 * 
 ***************************************************************************************************
 *                                         Category Definition                                     *
 ***************************************************************************************************
 * Here is a formal definition of a category following the presentation in Category Theory for 
 * Computing Sciences chapter 2.
 * 
 * We begin with a formal definition of a directed graph:
 * A directed graph C is a pair of functions source: C_0 -> C_1 and target: C_0 -> C_1. The elements
 * of C_0 we call nodes/objects and the elements of C_1 we call edges/arrows. An arrow path of
 * length n in C is a sequence of arrows arranged head to tail as follows:
 * 
 *      f_n    f_n-1    ...     f_2     f_1
 *   . ----> . ----> .  ...  . ----> . ----> . 
 *
 * Rendered using Javascript:*/
html { (* "
$$
\\begin{CD}
 \\cdot     @>f_n>> \\cdot  @>f_{n-1}>> \\cdot @. \\ldots @. \\cdot @>f_2>> \\cdot @>f_1>> \\cdot
\\end{CD}
$$
" *)
}
/* For any adjacent pair of arrows in such a path we must have target(f_k) = source(f_k-1). Such
 * adjacent pairs we call composable pairs. In such a graph one can define sets of paths of length n
 * which we designate C_n
 * 
 * The definition of a category extends the definition of a directed graph:
 * A category is a graph C together with two functions c: C_2 -> C_1 and u: C_0 -> C_1 with
 * properties C-1 through C-4 below. The function c we call composition, and if (f, g) is a
 * composable pair, c(f,g) is written f.g and is called the composite of f followed by g. If A is an 
 * object of C, u(A) is denoted id_A or just A, which is called the identity of the object A.
 * 
 * C-1 The source of f.g is the source of f and the target of f.g is the target of g.
 * C-2 (f.g).h = f.(g.h) whenever either is defined.
 * C-3 The source and target of id_A are both A.
 * C-4 If f: A -> B, id_A.f = f.id_B = f (alternatively A.f = f.B = f).
 * 
 * We now introduce the fourth block in the schema declaration below, the observation_equations 
 * block. The observation_equations block is an example of a path equation. Notice that 
 * SCNameOnSkill is an arrow from Skill to Varchar. As such it is a path of length one. Similarly
 * there is a path from Skill to Varchar that is a path of length two obtained by composing the 
 * foreign key arrow fk_HasClass with the attribute arrow SCName. The observation equation is a 
 * declaration that those two paths are equal.
 * 
 * The practical significance of this is far reaching, but in this case it provides us with a
 * mechanism to denormalize our schema while guaranteeing that no inconsistencies will be allowed. 
 * 
 * Much of the power of category theory comes from its polymorphic nature. Many different contexts
 * can be interpreted through the abstract lens of category theory. We will see in the coming
 * discussion that many of the kinds supported by AQL can be interpreted using category theory.
 ***************************************************************************************************/
schema sS = literal : TypeSide {
	entities
		Skill SkillClass
	foreign_keys
		fk_HasClass : Skill -> SkillClass
	attributes
		SName : Skill -> Varchar
		SCNameOnSkl : Skill -> Varchar
		SCName : SkillClass -> Varchar
	observation_equations
		SCNameOnSkl = fk_HasClass.SCName
		
}
/***************************************************************************************************
 *                                          Instances
 * 
 * As schemas extend the type side so instances extend schemas. An AQL instance can be
 * conceptualized as the data that "fills" a schema and consists of a set of generators for each
 * entity in the schema. The user can optionally create equational definitions which associate the
 * generator of one entity with that of another or a generator with an attribute value. In the
 * absence of such an association AQL will create what is called a skolum term. Skolum terms are
 * essential for creating a structure that can be formally defined and verified as consistent.
 * Skolum terms at a type are referred to as a labeled null. Skolum terms as an entity are referred 
 * to as a meaningless identifier. Notice that labeled nulls are very different than nulls in
 * currently available RDBMSs.
 * 
 * Every null in AQL is typed by its associated generator and the path to the location in a schema 
 * where a value is missing. For example, in the instance definition below we failed to provide any 
 * generators for skill classes and so AQL created a skolum term for each unknown skill class 
 * beginning with a skill generator followed by the foreign key path. So for the Math skill there 
 * is an unknown generator s0.fk_HasClass whose unknown name is s0.fk_HasClass.SCName.
 * 
 * The following is a representative instance of skills. The way to think about this representative
 * is that it is one member of a universe of possible instances all of which are derived from the
 * same schema type sS. To summarize, so far we have introduced the idea that AQL constructions are 
 * organized around the kind hierarchy:
 * 
 * typeside <- schema <- instance.
 * 
 * Running this file and selecting an instance below will display a tabular representation of each
 * instance.
 ***************************************************************************************************/
instance iSkl = literal : sS {
	generators
	    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill
	multi_equations
	    SName -> {s0 CategoryTheory, s1 CompSci, s2 DBA, s3 Pharma, s4 Programming, s5 Lecturing, 
	    		  s6 GrantWriting, s7 Finance, s8 Management, s9 PaperWriting}
}

/* Analogous to the skills instance above we create a representative instance for tasks. */
instance iTsk = literal : sT {
	generators
	    t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 : Task
	multi_equations
    TName -> {t1 LaunchCIStartup, t2 BuildAQL, t3 WriteAQLTutorial, t4 BuildPhrmColim, t5 BuildFncColim,
	              t6 WriteCTPaper, t7 TeachCT, t8 TeachCS, t9 RunPhrmIntProject, t10 RunFncIntProject}
}

/* The definition of an entity with a pair of attributes provides us with the ability to create an
 * instance that associates each such pair with the same generator. Here we illustrate this idea
 * with such a representative instance. */
instance iSnT = literal : sSnT {
	generators
		st1 st2 st3 st4 st5 st6 st7 st8 st9 st10
		st11 st12 st13 st14 st15 st16 st17 st18 st19 st20
		st21 st22 st23 st24: SkillNeededForTask
	multi_equations
		skill -> {st1 CompSci,            st2 Programming,      st3 GrantWriting,    st4 PaperWriting,
				  st5 CompSci,            st6 Programming,      st7 Management,
				  st8 Programming,        st9 Lecturing,        st10 PaperWriting,
				  st11 Pharma,            st12 Programming,
				  st13 Finance,           st14 Programming,
				  st15 CategoryTheory,    st16 PaperWriting,
				  st17 CategoryTheory,    st18 Lecturing,
				  st19 Pharma,            st20 Management,
				  st21 Finance,           st22 Management,
				  st23 CompSci,			  st24 Lecturing}
		task ->  {st1 LaunchCIStartup,    st2 LaunchCIStartup,  st3 LaunchCIStartup, st4 LaunchCIStartup,
				  st5 BuildAQL,           st6 BuildAQL,         st7 BuildAQL,
				  st8 WriteAQLTutorial,   st9 WriteAQLTutorial, st10 WriteAQLTutorial,
				  st11 BuildPhrmColim,    st12 BuildPhrmColim,
				  st13 BuildFncColim,     st14 BuildFncColim,
				  st15 WriteCTPaper,      st16 WriteCTPaper,
				  st17 TeachCT,           st18 TeachCT,
				  st19 RunPhrmIntProject, st20 RunPhrmIntProject,
				  st21 RunFncIntProject,  st22 RunFncIntProject,
				  st23 TeachCS,           st24 TeachCS}
}

/***************************************************************************************************
 *                                        Instance Categories                                      *
 ***************************************************************************************************
 * Like schemas, instances can also be viewed as categories. To make this clearer consider these
 * alternative syntaxes for declaring an instance using the equations keyword. The following are
 * both equivalent to the sSkl declaration above:

instance iSkl = literal : sS {
	generators
	    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill
	equations
	    s0.SName = CategoryTheory  	s1.SName = CompSci	    s2.SName = DBA
	    s3.SName = Pharma   		s4.SName = Programming  s5.SName = Lecturing
		s6.SName = GrantWriting		s7.SName = Finance		s8.SName = Management
		s9.SName = PaperWriting
}
instance iSkl = literal : sS {
	generators
	    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill
	equations
	    SName(s0) = CategoryTheory	SName(s1) = CompSci	    SName(s2) = DBA
	    SName(s3) = Pharma   		SName(s4) = Programming SName(s5) = Lecturing
		SName(s6) = GrantWriting	SName(s7) = Finance		SName(s8) = Management
		SName(s9) = PaperWriting
}
 * The objects of an instance category are the generators. The arrows are either a foreign key
 * evaluated at a generator or an attribute evaluated at a generator. Like a schema the literal
 * declaration of an instance is a presentation of an instance category. As you will see when you
 * run an AQL model with an instance declaration AQL will fill skolum terms as implied by the schema
 * and the provided generators.
 * 
 * Notice these equations declare instance arrows in a way that is closely analogous to an RDF 
 * triple. The subject of a triple is a generator, the object of a triple is either a literal (value 
 * on the type side) or another generator and the predicate is the type on the arrow as determined 
 * by the underlying schema. As such AQL instances are closely related to graph databases although 
 * they are very strongly typed by their underlying schema.
 * 
 * In order to extend the instance iSkl to include classes we need to decide how we want to
 * partition the skills we have into broad equivalence classes (we list the generators for 
 * convenience):
 * 
 *   Class 1: CategoryTheory, CompSci, DBA, Programming (s0, s1, s2, s4)
 *   Class 2: Pharma, Lecturing, Finance, Management (s3, s5, s7, s8)
 *   Class 3: GrantWriting, PaperWriting (s6, s9)
 *   
 * AQL provides the ability to extend any construction by importing a construction already in place,
 * so using the path dot notation we extend the iSkl instance as follows: */
instance iSklExt = literal : sS {
	imports
	   iSkl
	equations
	   s0.fk_HasClass = s1.fk_HasClass
	   s0.fk_HasClass = s2.fk_HasClass
	   s0.fk_HasClass = s4.fk_HasClass
	   s3.fk_HasClass = s5.fk_HasClass
	   s3.fk_HasClass = s7.fk_HasClass
	   s3.fk_HasClass = s8.fk_HasClass
	   s6.fk_HasClass = s9.fk_HasClass
}
/* Notice that each of the paths in the equations above have a direct correspondence with a skolum 
 * term. Hence, in contrast with traditional database null values, skolum terms can be manipulated 
 * in the same way any other value can be manipulated. If you compare iSkl and iSklExt in the 
 * runtime GUI you will note that the number of skolum terms has decreased from ten (one for each 
 * skill) to three (one for each equivalence class).
 * *************************************************************************************************
 *                             The Category of Instances of a Schema                               *
 * *************************************************************************************************
 * Now lets see if we can give these skill class labeled nulls labels. To do this we have to
 * introduce another example of a category, the universe of possible instances that are all based on 
 * a particular schema. For example all instances of sS define a category. The objects are instances 
 * of sS and we already have two examples, iSkl and iSklExt. The arrows are transforms from one
 * instance of sS to another instance of sS. A transform is an instance map that preserves the 
 * structure of the instance. We will return to transforms in a moment, but for now lets create a
 * third instance with labels for our three skill classes. */
instance iSklCls = literal : sS {
	generators
		sc0 sc1 sc2 : SkillClass
	equations
		sc0.SCName = Cognitive
		sc1.SCName = Social
		sc2.SCName = Psychomotor
}
/* An important idea in category theory is the notion of a universal construction. We now introduce
 * the AQL implementation of such a construction. The idea is that given a particular structure
 * defined by a diagram one can consider all possible examples of that structure in a particular
 * category. By that we mean all examples that have the same shape as the diagram in question. Let's
 * consider a diagram called a cospan. It has this shape: t1: A --> X <-- B :t2. As we were 
 * currently talking about the category of instances of the schema sS, the objects A, X and B are 
 * instances and the two arrows are transforms. A cospan in this category is any valid collection of
 * three instances of sS that are related to one another via a pair of transforms.
 * 
 * Given a choice of instances say iSklExt and iSklCls we can consider all possible ways of 
 * combining iSklExt and iSklCls with a pair of transforms to get a third instance X. The universal 
 * way of combining iSklExt and iSklCls to get an X is the one to which all others can be related in 
 * a unique way. That is to say, for any X and any pair of valid transforms t1 and t2 the universal 
 * cospan iA: iSklExt --> iSklCP <-- iSklCls :iB is the cospan such that there exists a unique 
 * transform:
 * 
 * t(t1,t2): iSklCP --> X such that
 * iA.t(t1,t2) = t1 and
 * iB.t(t1,t2) = t2
 * 
 * for any X and any pair of transforms (t1, t2). What this means is that the pair of arrows t1 and 
 * t2 can be replaced with the single arrow t(t1,t2).
 * 
 *****************************************Add diagram here.*****************************************
 * 
 * Conceptually this construction is a generalization of the SQL union all statement. It is a 
 * generalization in that it applies to a pair of instances of a schema rather than a pair of 
 * relations of a relvar. This construction is known as a coproduct since there is an analogous 
 * construction that takes the product of two instances obtained by reversing all of the arrows. We 
 * say that iA and iB are injections of the instances iSklExt and iSklCls into the coproduct. You 
 * can see the effect of this construction by running this file and selecting iSklCP in the viewer. */
instance iSklCP = coproduct iSklExt iSklCls : sS

/* Now that we have all of the desired records in the same instance we want to identify the
 * generators that came from iSklCls with the skolum terms that came from the iSklExt instance. To 
 * achieve this result we would like to declare that each of the skolum terms from iSklExt should be 
 * merged with the appropriate generator coming from iSklCls. Recall we have already done this by 
 * importing an existing instance into a new instance and adding equations. Here is the solution
 * using that approach. */
instance iSklSklCls1 = literal : sS {
	imports
	  iSklCP
	equations
	  s0.fk_HasClass = sc0
	  s3.fk_HasClass = sc1
	  s6.fk_HasClass = sc2
}

/* There is an alternative construction that is universal. First we create the instance iSLnk with a 
 * generator for each of the skill classes. We then create two instance transforms, the first 
 * mapping each link generator to a iSklExt skolum term and the second mapping each link generator 
 * to our iSklCls generators. The new universal construction is known as a coequalizer. An instance 
 * coequalizer uses a pair of transforms to define collections of records that are identified as 
 * equal. This approach has the advantage that linking instances and transforms can be imported from 
 * an external database using SQL queries.
 * 
 *****************************************Add diagram here.*****************************************
 * 
 * This construction is a generalization of the notion of partitioning a set into equivalence
 * classes. Later we will see how these constructions can be applied to other categories in AQL. */
instance iSLnk = literal : sS {
	generators
		scLnk0 scLnk1 scLnk2 : SkillClass
}
transform tS1 = literal : iSLnk -> iSklCP {
	generators
		scLnk0 -> s0.fk_HasClass
		scLnk1 -> s3.fk_HasClass
		scLnk2 -> s6.fk_HasClass
}
transform tS2 = literal : iSLnk -> iSklCP {
	generators
		scLnk0 -> sc0
		scLnk1 -> sc1
		scLnk2 -> sc2
}
instance iSklSklCls2 = coequalize tS1 tS2

/***************************************************************************************************
 *                                        AQL Queries and                                          *
 *                                    The Category of Schemas                                      *
 ***************************************************************************************************
 * The next example of a category we need is the category of schemas. Since a schema can be viewed
 * as presentations of categories the category of schemas is closely related to the category of
 * categories. The objects of the category of schemas is of course schemas and the arrows are
 * referred to in AQL as mappings. There is a syntax for the literal declaration of a mapping that 
 * is provided by AQL, but we will not elaborate on that syntax as you will see that most
 * applications of mappings are either implicit in other constructions or generalizations to
 * mappings as in the case of queries which we introduce in this section. 
 * 
 * Conceptually mappings preserve the structure of a schema, that is, they map entities and foreign
 * keys/attributes in a consistent way. For the interested reader the name given mappings in the
 * mathematical literature is functor, as functors can be viewed as a generalized function. Queries
 * further generalize mappings in the same way that a cospan A -> B <- C generalizes a single arrow 
 * A -> C. 
 * 
 * AQL queries can be used to extract some part of a schema instance as well as to calculate derived 
 * results. This construction is referenced by the query keyword. We illustrate in our first example
 * a simple form of an AQL query that is very similar to an SQL query.
 * 
 *  -The from clause: like SQL lists the entities from which the query is constructed. AQL differs
 *   in that each entity must be provided with a variable that serves as a representative generator
 *   for that entity. This is syntactically similar to an SQL alias though no optional.
 *  -The where clause: Again similar to the where clause in SQL in that it provides a means for
 *   filtering records and joining entities.
 *  -The return clause: The return clause is analogous to the select clause in SQL and defines what
 *   the query output is.
 *   
 * We make use of the Java string method "matches" we have exposed through the type side. This
 * method allows us to pass a regular expression that can be used as a filter for any skill name 
 * ending in the string "Writing".
 ***************************************************************************************************/
query qWrtngSklS = simple : sS {
	from
	  s: Skill
	where
	  Matches(s.SName, ".*Writing") = true
	return
	  Skill_Name -> s.SName
	  Skill_Class_Name -> s.SCNameOnSkl
}

/* By virtue of AQL's ability to define multiple instances associated with a schema, to execute a
 * query it must be evaluated on an instance to define a new instance. When queries are of the
 * simple type as in this example the schema is implicitly defined as having a single entity with
 * attributes as listed in the return clause. */
instance iWrtngSklS = eval qWrtngSklS iSkl

/* To illustrate the more complete query syntax we must explicitly declare a target schema. Below
 * we rewrite qWrtngSklS to illustrate the more complete syntax. First we define the target schema
 * with a single entity tSkill and the two attributes listed in the return clause above: */
schema sSkl = literal : TypeSide {
	entities
	  tSkill
	attributes
	  Skill_Name : tSkill -> Varchar
	  Skill_Class_Name : tSkill -> Varchar
}

/* Next we create a query whose kind is an arrow from the source schema sS to the target schema
 * sSkl. This complete syntax requires a query sub-block for each entity in the target schema. 
 * Additionally the complete syntax requires an assignment for all attributes defined in the target 
 * schema. The query qWrtngSklC is functionally equivalent to qWrtngSklS. If you run this model you 
 * will notice that the instance iWrtngSklS is identical to the instance iWrtngSklC. */
query qWrtngSklC = literal : sS -> sSkl {
	entities
	  tSkill -> {
	  	from
	  	  s: Skill
	  	where
		  Matches(s.SName, ".*Writing") = true
	  	return
		  Skill_Name -> s.SName
		  Skill_Class_Name -> s.SCNameOnSkl
	  }
}
instance iWrtngSklC = eval qWrtngSklC iSkl

/* Queries as structure preserving maps of schemas have the capability of mapping not only entities
 * but also foreign keys. In this example we will build a query that has as its source and target 
 * schemas sS but is not an identity. Generally mappings that have the same source and target are 
 * called endomaps. This example filters for those skills that are classified as social skills.
 * 
 * Given it's novel nature, let's take a moment to elaborate on the syntax of the foreign_keys 
 * block. We have duplicated the declaration of the foreign key we are constructing in a comment as 
 * reference. The fk_HasClass foreign key enforces a functional dependency between the generators of
 * the entity Skill and the generators of of the entity SkillClass. In the entities block we have
 * generator variables sc for the SkillClass entity and s for the Skill entity that vary over the
 * the generators of those two entities in the source instance. The task at hand is to use those
 * variables and the source foreign key to construct a functional dependency in the target schema.
 * We do this by taking a SkillClass generator and assigning it as the return value of the target 
 * foreign key fk_HasClass. Which generator do we assign? The one we get by taking a skill
 * generator and following it to its skill class. Notice that this is opposite to the direction of 
 * the arrow associated with the fk_SkillClass functional dependency.
 * 
 * Note: If you removed the where clause from each entity sub-block you would have the identity 
 * mapping. */
query qEndoS = literal : sS -> sS {
	entities
	  SkillClass -> {
	  	from
	  	  sc: SkillClass
	  	where
	  	  sc.SCName = Social
	  	return
	  	  SCName -> sc.SCName
	  }
	  Skill -> {
	  	from
	  	  s: Skill
	  	where
	  	  s.fk_HasClass.SCName = Social
	  	return
	  	  SName -> s.SName
	  	  SCNameOnSkl -> s.SCNameOnSkl
	  }
	foreign_keys
	  // fk_HasClass : Skill -> SkillClass
	  fk_HasClass -> {sc -> s.fk_HasClass}
}
instance iSocialSkl = eval qEndoS iSklSklCls1

/***************************************************************************************************
 *                                        Schema Colimit
 * 
 * Next we introduce an AQL feature that allows us to assemble multiple source schemas into a single
 * target schema. This construction is called a schema colimit by virtue of its mathematical origins
 * in category theory. Generally colimits are a class of universal constructions that take a diagram
 * of objects connected by arrows and assemble those objects in a way consistent with the diagram.
 * We have already seen an example of a colimit in the instance coproduct. Now we apply AQL's
 * implementation of that same universal construction to the category of schemas. When applied to
 * schemas the coproduct results in a construction analogous to what is sometimes called "landing"
 * tables from multiple source schemas into a single schema where data transforms can be 
 * conveniently developed.
 * 
 * In this particular case we "land" the three schemas sT, sS, sSnT using the single structure
 * S_T_SnT_SumAuto whose type is schema_colimit. We will develop the connection of a schema 
 * coproduct with a instance coproduct in a moment, but for now examine the automatically generated 
 * coproduct in the runtime viewer.
 ***************************************************************************************************/
schema_colimit S_T_SnT_SumAuto = coproduct sT + sS + sSnT : TypeSide
//schema_colimit S_T_SnT_SumAuto = quotient sT + sS + sSnT: TypeSide {}


/* The automatically generated schema colimit prefixes each object within the target schema with the
 * label associated with the source schema from which that object originated. With the modify
 * command we have the option of providing whatever names we choose independent of the names
 * associated with the source schemas from which they originated. In this case we designate each
 * entity with the prefix l to indicate that it was landed using the coproduct operation. */
schema_colimit S_T_SnT_Sum = modify S_T_SnT_SumAuto {
	rename entities
		sS_Skill -> lSkill
		sS_SkillClass -> lSkillClass
		sT_Task -> lTask
		sSnT_SkillNeededForTask -> lSkillNeededForTask
	rename foreign_keys
		sS_fk_HasClass -> lfk_HasClass
	rename attributes
		sS_SName -> lSName
		sS_SCNameOnSkl -> lSCNameOnSkl
		sS_SCName -> lSCName
		sT_TName -> lTName
	    sSnT_skill -> lskill
	    sSnT_task -> ltask
}

/*************************************************************************************************** 
 *  								 schema_colimit Diagram
 *  
 * Recalling our earlier description of the instance coproduct which was a cospan of instances, a 
 * schema coproduct is a cospan of schemas and as such includes a schema and a pair of structure
 * preserving maps of schemas.  
 * 
 * With the sequence of constructions below we reveal that inner structure of the schema colimit.
 * This structure consists of a target schema and a schema mapping from each source schema to that 
 * target. This means that a schema colimit can be thought of as a diagram of schemas and schema 
 * mappings. In this particular case, using the labels assigned below, we have the following 
 * diagram:
 * 
 *                      mSToS_T_SnT_Sum        mTToS_T_Snt_Sum
 *                      sS --------> sS_T_Snt_Sum <-------- sT
 *                                        /\
 *                      mSnTToS_T_SnT_Sum |
 *                                        |
 *                                      sSnT
 * 
 ***************************************************************************************************/
schema sS_T_SnT_Sum = getSchema S_T_SnT_Sum
mapping mSToS_T_SnT_Sum = getMapping S_T_SnT_Sum sS
mapping mTToS_T_Snt_Sum = getMapping S_T_SnT_Sum sT
mapping mSnTToS_T_SnT_Sum = getMapping S_T_SnT_Sum sSnT

/***************************************************************************************************
 *                   The Category of the Category of Instances of a Schema                         *
 *                                  Sigma --| Dela --| Pi                                          *
 ***************************************************************************************************
 * Let's recap where we are. We have a set of three source schemas sS, sT and sSnT, each with an
 * instance; iSklSklCls1, iTsk and iSnT respectively. We have a target schema sS_T_SnT_Sum. We also
 * have mappings that take each source schema to the target schema. What we want is a construction
 * similar to eval that can be applied to a mapping rather than a query, but the schema colimit is
 * giving us mappings not queries.
 * 
 * Recall that queries generalize mappings. It so happens there are three constructions that are 
 * related to eval in the same way mappings are related to queries. In fact eval and it's dual 
 * coeval, which we have not discussed, are generalizations of these constructions. To develop these 
 * ideas would be a lengthy digression so we will only mention them in passing along with some 
 * informal remarks about their properties. 
 * 
 * These three constructions are called sigma, pi and delta. They are universal and they all can be 
 * understood as moving instance data through mappings in a way that is analogous to how eval moves
 * instances through queries. Sigma, pi and delta are all "mappings" of a richer category of 
 * instances typed by schemas or instance categories. This means that sigma, pi and delta map not 
 * only instances but instance transforms. These three mappings are related as follows. Delta pulls 
 * data backward through a mapping and generalizes the notion of projection. Both Sigma and Pi push 
 * data forward through a mapping and generalize sums/unions and products/joins respectively. Delta 
 * can be paired with sigma on the left and pi on the right to create data migration round trips.
 * 
 * To see this, consider schemas sA, sB, mapping m and instance iA of sA. Without yet specifying   
 * specifics the AQL syntax would be:
 
mapping m = literal : sA -> sB {...} 
instance iB = literal : sB {...}

 * Delta can move the instance iB backward through m into sA as follows:
 
instance iDlt_m_iB = delta m iB
 
 * Similarly, sigma can move this new instance forward through m into sB:
 
instance iSgmDlt_m_iB = delta m iDlt_m_iB
 
 * A natural thing to ask is how iSgmDlt_m_iB and iB are related. The answer is they are related by
 * a transform known as the unit of the sigma --| delta adjoint pair. Notice we could also start
 * with an instance iA of sA and apply first sigma and then delta to an instance iDltSgm_m_iA. iA
 * and iDltSgm_m_iA are related by the counit of the sigma --| delta adjoint pair. In a similar way            
 * delta --| pi form an adjoint pair with associated unit and counit transforms. We say that delta 
 * is right adjoint to sigma and left adjoint to pi.
 * 
 * Of the three, sigma has the property that generators of the source instance are preserved in the 
 * target instance. This means we can move instances and transforms between schemas in a way that 
 * permits us to merge instance data. Let's see how we can use sigma to solve the problem at hand
 * and later we will return to broader questions about the category of instances typed by schemas.
 * 
 * Recall we have a target schema that contains all of the entities from our three source schemas
 * we can use the sigma construction to push the instances in the source schemas forward through the 
 * mappings generated by the schema_colimit construction to create an instance in the sS_T_SnT_Sum
 * assembly. Having done so we would have three separate instances in the target schema 
 * sS_T_SnT_Sum. With all of these instances in the same schema we can make use of our familiar
 * instance coproduct construction. This would look like the following:

instance iSklSklCls_In_S_T_SnT_Sum = sigma mSToS_T_SnT_Sum iSklSklCls1
instance iTsk_In_S_T_SnT_Sum = sigma mSToT_T_SnT_Sum iTsk
instance iSnT_In_S_T_SnT_Sum = sigma mSnTToS_T_SnT_Sum iSnT
instance iS_T_SnT_Sum = coproduct
	iSklSklCls_In_S_T_SnT_Sum
	iTsk_In_S_T_SnT_Sum
	iSnT_In_S_T_SnT_Sum
	: sS_T_SnT_Sum
	
 * AQL provides the coproduct_sigma construction which performs the above sequence in one step: */

instance iS_T_SnT_Sum = coproduct_sigma
   mSToS_T_SnT_Sum iSklSklCls1
   mTToS_T_Snt_Sum iTsk
   mSnTToS_T_SnT_Sum iSnT
   : sS_T_SnT_Sum
   
/*************************************************************************************************** 
 *                                       AQL Queries Continued
 *  
 * In the current context we have as source schema the result of the colimit construction. If you
 * run this file and look at the colimit schema sS_T_SnT_Sum and associated instance you will
 * discover the we have assembled a target schema where the entities of the source schemas 
 * are independent of one another. We now use the query construction to introduce foreign key 
 * constraints in a way that is analogous to the addition of the foreign key constraints supported 
 * in RDBMSs.
 * 
 * Recall that a non-simple AQL query requires we define the target schema first. This schema is
 * identical to the output of the colimit construction but with the addition of a pair of foreign
 * keys from the SkillNdFrTask entity with the (skill, task) attribute pair to the Skill and Task 
 * entities respectively. This produces a schema which is known in category theory as a span and it 
 * can again be summarized as a diagram, but in contrast with the case of the colimit construction 
 * this is a diagram of entities rather than schemas. We have enclosed the Skill and SkillClass 
 * entities with parentheses to indicate that they serve as a reference taxonomy.
 *
 *           fk_HasClass    fk_SnT_S             fk_SnT_T
 * (SkillClass <----- Skill) <----- SkillNdFrTask -----> Task
 *     
 * We again make use of the observation_equations block to denormalize all of the attributes that 
 * are available through paths as attributes directly available to the SkillNdFrTask entity.
 ***************************************************************************************************/
schema sSTSpn = literal : TypeSide {
	entities
	  Skill SkillClass
	  Task
	  SkillNdFrTask
	foreign_keys
	  fk_HasClass    : Skill -> SkillClass
	  fk_SkillNeeded : SkillNdFrTask -> Skill
	  fk_ForTask     : SkillNdFrTask -> Task
	attributes
	  SName         : Skill -> Varchar
	  SCNameOnSkl   : Skill -> Varchar
	  SCName        : SkillClass -> Varchar
	  TName         : Task -> Varchar
	  skill         : SkillNdFrTask -> Varchar
	  skillclass	: SkillNdFrTask -> Varchar
	  task          : SkillNdFrTask -> Varchar
	observation_equations
	  SCNameOnSkl = fk_HasClass.SCName
	  skill = fk_SkillNeeded.SName
	  skillclass = fk_SkillNeeded.fk_HasClass.SCName
	  task = fk_ForTask.TName
}

/* Given the similarity of the source and target schemas the entity sub-blocks are all direct
 * mappings that reproduce exact copies of the source entities instances with those of the target
 * entities with the exception of the SkllNdFrTask target entity. In order to construct that entity 
 * we must have generators on both side of the new foreign keys we are introducing. By default when
 * multiple source generator variables are provided for a target entity each generator for the 
 * target comes from the Cartesian product of the source generators. The where clause has two
 * equations implicitly connected by a logical and. This effectively constrains the target entities
 * to an equationally defined subset of a Cartesian product, also known as a join, so this 
 * construction effectively joins the three source entities and makes all of their generators
 * available for the creation of the new foreign keys. The foreign keys can now be assigned the
 * values for the Skill and Task generators based on the values in the SkillNdFrTask block. */
query qS_T_SnT_SumToSTSpn = literal : sS_T_SnT_Sum -> sSTSpn {
	entities
		Skill -> {
			from
				ss : lSkill
			return
				SName -> ss.lSName
				SCNameOnSkl -> ss.lSCNameOnSkl
		}
		SkillClass -> {
			from
				scsc : lSkillClass
			return
				SCName -> scsc.lSCName
		}
		SkillNdFrTask -> {
			from
				snt : lSkillNeededForTask
				sn  : lSkill
				nt  : lTask
			where
				snt.lskill = sn.lSName
				snt.ltask = nt.lTName
			return
				skill -> snt.lskill
				skillclass -> sn.lfk_HasClass.lSCName
				task  -> snt.ltask
		}
		Task -> {
			from
				tt : lTask
			return
				TName -> tt.lTName
		}
	foreign_keys
		// fk_HasClass : Skill -> SkillClass
		fk_HasClass    -> {scsc -> ss.lfk_HasClass}
		// fk_SnT_S    : SkillNdFrTask -> Skill
		fk_SkillNeeded -> {ss -> sn}
		// fk_SnT_T    : SkillNdFrTask -> Task
		fk_ForTask     -> {tt -> nt}
}

/* Pushing the instance generated by the coproduct_sigma construction through the query above using
 * eval produces an instance reflecting the foreign keys introduced in the target schema we set up 
 * as part of the query definition. */
instance iSTSpn = eval qS_T_SnT_SumToSTSpn iS_T_SnT_Sum

/* Having constructed a span modeling the way skills are related to tasks, we now turn to another
 * model involving a span relating skills to people. We could build this model up piece by piece as
 * we did above, but in this case we illustrate how AQL can extract existing data from a relational
 * database into an AQL schema. The schema below defines the structure into which we target our  
 * import. */
schema sSPSpn = literal : TypeSide {
	entities
	  SpecificSkill GeneralSkill SkillClass
	  Person SkillPrvdByPerson
	foreign_keys
	  fk_IsType : SpecificSkill -> GeneralSkill
	  fk_HasClass : GeneralSkill -> SkillClass
	  fk_SpP_S   : SkillPrvdByPerson -> SpecificSkill
	  fk_SpP_P   : SkillPrvdByPerson -> Person
	attributes
	  SSName SSGSName SSSCName : SpecificSkill -> Varchar
	  GSName GSSCName : GeneralSkill -> Varchar
	  SCName : SkillClass -> Varchar
	  PName  : Person -> Varchar
	  skill  : SkillPrvdByPerson -> Varchar
	  person : SkillPrvdByPerson -> Varchar
	observation_equations
	  SSGSName = fk_IsType.GSName
	  SSSCName = fk_IsType.fk_HasClass.SCName
	  GSSCName = fk_HasClass.SCName
	  skill = fk_SpP_S.SSName
	  person = fk_SpP_P.PName
}

/* Here we use a Jdbc driver with each entity of the target schema populated by a select statement 
 * against the source database. */
instance iSPSpnImp = import_jdbc "com.mysql.jdbc.Driver"
	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" : sSPSpn {
   // entities - create generators for each entity based on the primary key of each entity in the source database
   SpecificSkill -> "select id, fk_IsType, SSName, SSGSName, SSSCName from sps2_SpecificSkill"
   GeneralSkill -> "select id, fk_HasClass, GSName, GSSCName from sps2_GeneralSkill"
   SkillClass -> "select id, SCName from sps2_SkillClass"
   Person -> "select id, PName from sps2_Person"
   SkillPrvdByPerson -> "select id, fk_SpP_S, fk_SpP_P, skill, person from sps2_SkillPrvdByPerson"
}


/* We export the instance iSTSpn to MySQL for use in later stages of this tutorial.
 * First clean out the target tables if present from a previous run. 
pragma pCleanUp = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"DROP TABLE IF EXISTS sts_SkillNdFrTask"
"DROP TABLE IF EXISTS sts_Skill"
"DROP TABLE IF EXISTS sts_Task"}

// Export the results of the above construction of the span and its representative instance.
pragma eSTS = export_jdbc_instance iSTSpn "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" "sts_"
  { options varchar_length = 256 }

// Display the contents of the ci_test schema in MySQL
pragma pp2 = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"SHOW  TABLES"}


// Bring the exported instance back in for round trip (export iSTSpan import iSTSpnImp) comparison.
instance iSTSpnImp = import_jdbc "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" : sSTSpn {
   // entities - create generators for each entity based on the primary key of each entity in the source database
   Skill -> "select id from sts_Skill"
   Task -> "select id from sts_Task"
   SkillNdFrTask -> "select id from sts_SkillNdFrTask"
   // foreign keys
   fk_SnT_S -> "select id, fk_SnT_S from sts_SkillNdFrTask"
   fk_SnT_T -> "select id, fk_SnT_T from sts_SkillNdFrTask"
   // attributes
   SName -> "select id, SName from sts_Skill"
   TName -> "select id, TName from sts_Task"
   skill -> "select id, skill from sts_SkillNdFrTask"
   task -> "select id, task from sts_SkillNdFrTask"
}
*/
