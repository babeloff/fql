

typeside TyJava = literal { 
	java_types
		string = "java.lang.String"
		nat = "java.lang.Integer"
	java_constants
		string = "return input[0]"
		nat = "return java.lang.Integer.parseInt(input[0])"
	java_functions
		plus : nat,nat -> nat = "return (input[0] + input[1]).intValue()"
}

schema S = literal : TyJava {
	entities
		Employee 
		Department
	foreign_keys
		manager   : Employee -> Employee
		worksIn   : Employee -> Department
		secretary : Department -> Employee
	path_equations 
		manager.worksIn = worksIn
  		secretary.worksIn = Department
  		manager.manager = manager
  	attributes
  		first last	: Employee -> string
     	age			: Employee -> nat
     	name 		: Department -> string
}

instance I = literal : S {
	generators 
		a b c : Employee
		m s : Department
	equations 
		first(a) = Al
		first(b) = Bob  last(b) = Bo
		first(c) = Carl 
		name(m)  = Math name(s) = CS
		age(a) = age(c) 
		manager(a) = b manager(b) = b manager(c) = c
		worksIn(a) = m worksIn(b) = m worksIn(c) = s
		secretary(s) = c secretary(m) = b 
		secretary(worksIn(a)) = manager(a)
		worksIn(a) = worksIn(manager(a))
		age(a) = "2" 
		age(manager(a)) = "1"
}

schema one = literal : TyJava {
	entities 
		O
}

query Q = literal : S -> one {
	entities
	O -> {
		from e:Employee
			 d:Department
		where e.manager = d.secretary
	}
}

instance FrozenInstForQonO = literal : S {
	generators
		e:Employee
		d:Department
	equations
		e.manager = d.secretary
}

instance J = eval Q I

//the three rows in J=eval(Q)(I) correspond to the three transforms row1,row2,row3
transform row1 = literal : FrozenInstForQonO -> I {
	generators
		e -> c
		d -> c.worksIn
}

transform row2 = literal : FrozenInstForQonO -> I {
	generators
		e -> a
		d -> a.manager.worksIn
}

transform row3 = literal : FrozenInstForQonO -> I {
	generators
		e -> a.manager
		d -> a.manager.worksIn
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

typeside Type = literal {
	java_types	
		dom = "java.lang.Object"
	java_constants
		dom = "return input[0]"
}

schema CoSpan = literal : Type {
	entities
		B C D
 	foreign_keys
		f: B -> D
		g: C -> D
	attributes
		B_att : B -> dom
		C_att : C -> dom	
} 

schema Square = literal : Type {
	imports
		CoSpan
	entities
		A
 	foreign_keys
		f2: A -> B
		g2: A -> C
	path_equations
		f2.f=g2.g
	attributes
		A_attB : A -> dom
		A_attC : A -> dom	
} 

instance I0 = literal : CoSpan {
	generators
		b1 b2 : B
		c1 c2 : C
		d1 d2 d3 : D
	equations
		b1.B_att = "b1"@dom
		b2.B_att = "b2"@dom
		c1.C_att = "c1"@dom
		c2.C_att = "c2"@dom
		b1.f = d1
		b2.f = d2
		c1.g = d1
		c1.g = d3 
}

query pullback = literal : CoSpan -> Square {
 entities
 
	D -> {from d:D}
		
	B -> {from b:B 
		 return B_att -> b.B_att}

	C -> {from c:C 
		 return C_att -> c.C_att}

	A -> {from b0:B c0:C 
		 where b0.f = c0.g 
		 return A_attB -> b0.B_att 
		 	   A_attC -> c0.C_att} 

 foreign_keys		 	   

	f -> {d -> b.f}
	g -> {d -> c.g}

	f2 -> {b -> b0}
	g2 -> {c -> c0}
}

instance FrozenForA = literal : CoSpan {
	generators
		b0:B c0:C 
	equations
		b0.f = c0.g 
}

instance FrozenForC = literal : CoSpan {
	generators
		c:C 
}

instance FrozenForB = literal : CoSpan {
	generators
		b:B
}

instance FrozenForD = literal : CoSpan {
	generators
		d:D
}

//f : B -> D
transform FrozenForf = literal : FrozenForD -> FrozenForB {
	generators 
		d -> b.f 
}

//g : C -> D
transform FrozenForg = literal : FrozenForD -> FrozenForC {
	generators 
		d -> c.g 
}

//f2 : A -> B
transform FrozenForf2 = literal : FrozenForB -> FrozenForA {
	generators 
		b -> b0 
}

//g2 : A -> C
transform FrozenForg2 = literal : FrozenForC -> FrozenForA {
	generators 
		c -> c0 
}

// attribute stuff

//a "representable" instance of some kind - ask David
instance FrozenForDom = literal : CoSpan {
	generators
		x : dom
}

transform FrozenForBAtt = literal : FrozenForDom -> FrozenForB {
	generators
		x -> b.B_att  
}

transform FrozenForCAtt = literal : FrozenForDom -> FrozenForC {
	generators
		x -> c.C_att  
}

transform FrozenForAAttB = literal : FrozenForDom -> FrozenForA {
	generators
		x -> b0.B_att  
}

transform FrozenForAAttC = literal : FrozenForDom -> FrozenForA {
	generators
		x -> c0.C_att  
}
