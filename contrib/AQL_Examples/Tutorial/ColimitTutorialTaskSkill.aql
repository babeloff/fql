typeside TypeSide = literal {
	java_types
		Varchar = "java.lang.String"
	java_constants
		Varchar = "return input[0]"
}

// Schema with the single entity Skill.
schema sS = literal : TypeSide {
	entities
		Skill
	attributes
		SName : Skill -> Varchar
}

// Schema with the single entity Task.
schema sT = literal : TypeSide {
	entities
		Task
	attributes
		TName : Task -> Varchar
}

// Instance of skills
instance iSkl = literal : sS {
	generators
	    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill
	multi_equations
	    SName -> {s0 Math, s1 CompSci, s2 DBA, s3 Pharma, s4 Programming, s5 Teaching, 
	    		  s6 GrantWriting, s7 Finance, s8 Management, s9 PaperWriting}
}

// Instance of tasks
instance iTsk = literal : sT {
	generators
	    t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 : Task
	multi_equations
	    TName -> {t1 LaunchStartup, t2 BuildSWProduct, t3 WriteTutorial, t4 BuildPhrmColim, t5 BuildFncColim,
	              t6 WriteMathPaper, t7 TeachMath, t8 TeachCS, t9 RunPhrmIntProject, t10 RunFincIntProject}
}
/* Don't really need this, more of a distraction. More of an exercise to be sure I knew where I was going.
// Create a new schema that takes the coproduct of the sT and sS schemas to create a single
// schema with two entities Task and Skill.
schema_colimit S_T_SumAuto = quotient sT + sS : TypeSide {}

// Give the default names in the automatically generated sum more consise names.
schema_colimit S_T_Sum = modify S_T_SumAuto {
	rename entities
		sS_Skill -> Skill
		sT_Task -> Task
	rename attributes
		sS_SName -> SName
		sT_TName -> TName
}

// Provide addressable labels for the various components of the coproduct STSum
schema sS_T_Sum = getSchema S_T_Sum
mapping mSkillToS_T_Sum = getMapping S_T_Sum sS
mapping mTaskToS_T_Sum = getMapping S_T_Sum sT

// Build an instance for sSTSum from iTsk and iSkl
instance iS_T_Sum = coproduct_sigma
   mSkillToS_T_Sum iSkl
   mTaskToS_T_Sum iTsk
   : sS_T_Sum

// Create the product of skills and tasks 
schema sS_T_P = literal : TypeSide {
	entities
		Skill Task SkillxTask
	foreign_keys
		pSkill : SkillxTask -> Skill
		pTask : SkillxTask -> Task
	attributes
		SName : Skill -> Varchar
		TName : Task -> Varchar
		SofSTPair : SkillxTask -> Varchar
		TofSTPair : SkillxTask -> Varchar
    observation_equations
        forall s. s.pSkill.SName = s.SofSTPair
        forall t. t.pTask.TName = t.TofSTPair
}

// Populate the product with query
query qS_T_SumToS_T_P = literal : sS_T_Sum -> sS_T_P {
	entities //source entities: Skill Task
		Skill -> {
			from
				ss :Skill
			return
				SName -> ss.SName
		}
		Task -> {from
				tt : Task
			return
				TName -> tt.TName
		}
		SkillxTask -> {
			from
				ps : Skill
				pt : Task
			return
				SofSTPair -> ps.SName
				TofSTPair -> pt.TName
		}
	foreign_keys
		pSkill -> {ss -> ps}
		pTask -> {tt -> pt}
}

instance iS_T_P = eval qS_T_SumToS_T_P iS_T_Sum

// Export the instance iSTP to SQL
pragma pCleanUp = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"DROP TABLE IF EXISTS stp_SkillxTask"
"DROP TABLE IF EXISTS stp_Skill"
"DROP TABLE IF EXISTS stp_Task"} 

pragma eSTP = export_jdbc_instance iS_T_P "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" "stp_"
  { options varchar_length = 256 }

pragma pp = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"SHOW  TABLES"}
 
// Bring the exported instance back in
instance iS_T_PImp = import_jdbc "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" : sS_T_P {
   // entities - create generators for each entity based on the primary key of each entity in the source database
   Skill -> "select id from stp_Skill"
   Task -> "select id from stp_Task"
   SkillxTask -> "select id from stp_SkillxTask"
   // foreign keys
   pSkill -> "select id, pSkill from stp_SkillxTask"
   pTask -> "select id, pTask from stp_SkillxTask"
   // attributes
   SName -> "select id, SName from stp_Skill"
   TName -> "select id, TName from stp_Task"
   SofSTPair -> "select id, SofSTPair from stp_SkillxTask"
   TofSTPair -> "select id, TofSTPair from stp_SkillxTask"
}
*/

// Schema with one entity that assigns skills to tasks
schema sSnT = literal : TypeSide {
	entities
	  SkillNeededForTask
	attributes
	  skill : SkillNeededForTask -> Varchar
	  task : SkillNeededForTask -> Varchar
}

instance iSnT = literal : sSnT {
	generators
		st1 st2 st3 st4 st5 st6 st7 st8 st9 st10
		st11 st12 st13 st14 st15 st16 st17 st18 st19 st20
		st21 st22 : SkillNeededForTask
	multi_equations
		skill -> {st1 CompSci,         st2 Programming,     st3 GrantWriting,    st4 PaperWriting,
				  st5 CompSci,         st6 Programming,     st7 Management,
				  st8 Programming,     st9 Teaching,        st10 PaperWriting,
				  st11 Pharma,         st12 Programming,
				  st13 Finance,        st14 Programming,
				  st15 Math,           st16 PaperWriting,
				  st17 Math,           st18 Teaching,
				  st19 Pharma,         st20 Management,
				  st21 Finance,        st22 Management}
		task ->  {st1 LaunchSWStartup, st2 LaunchSWStartup, st3 LaunchSWStartup, st4 LaunchSWStartup,
				  st5 BuildSWProduct,  st6 BuildSWProduct,  st7 BuildSWProduct,
				  st8 WriteTutorial,   st9 WriteTutorial,   st10 WriteTutorial,
				  st11 BuildPhrmColim, st12 BuildPhrmColim,
				  st13 BuildFncColim,  st14 BuildFncColim,
				  st15 WriteMathPaper, st16 WriteMathPaper,
				  st17 TeachMath,      st18 TeachMath,
				  st19 RunPhrmProject, st20 RunPhrmProject,
				  st21 RunFncProject,  st22 RunFncProject}
}

// Create a new schema that takes the coproduct of the sT, sS and sSnT schemas to create a single
// schema with three entities Task and Skill and SkillNeededForTask.
schema_colimit S_T_SnT_SumAuto = quotient sT + sS + sSnT: TypeSide {}

// Give the default names in the automatically generated sum more consise names.
schema_colimit S_T_SnT_Sum = modify S_T_SnT_SumAuto {
	rename entities
		sS_Skill -> Skill
		sT_Task -> Task
		sSnT_SkillNeededForTask -> SkillNeededForTask
	rename attributes
		sS_SName -> SName
		sT_TName -> TName
	    sSnT_skill -> skill
	    sSnT_task -> task
}

// Provide addressable labels for the various components of the coproduct STSum
schema sS_T_SnT_Sum = getSchema S_T_SnT_Sum
mapping mSkillToS_T_SnT_Sum = getMapping S_T_SnT_Sum sS
mapping mTaskToS_T_Snt_Sum = getMapping S_T_SnT_Sum sT
mapping mSkillNeededForTaskToS_T_SnT_Sum = getMapping S_T_SnT_Sum sSnT

// Build an instance for sS_T_SnT_Sum from iTsk, iSkl and iSnT
instance iS_T_SnT_Sum = coproduct_sigma
   mSkillToS_T_SnT_Sum iSkl
   mTaskToS_T_Snt_Sum iTsk
   mSkillNeededForTaskToS_T_SnT_Sum iSnT
   : sS_T_SnT_Sum

/* This is cool, but is something of a tangent. I really just want to create the span.
 * The idea here is to create a schema that adds both the product and a span based on the Skill,  
 * Task and SkillNeededForTask entities and establishes the unique arrow between the two required
 * by the universal mapping property.
 */
schema sSTJoy = literal : TypeSide {
	entities
	  Skill Task
	  SkillNdFrTask SkillxTask
	foreign_keys
	  fk_pSkill  : SkillxTask -> Skill
	  fk_pTask   : SkillxTask -> Task
	  fk_SnT_S   : SkillNdFrTask -> Skill
	  fk_SnT_T   : SkillNdFrTask -> Task
	  fk_SnT_SxT : SkillNdFrTask -> SkillxTask
	path_equations
	  fk_SnT_SxT.fk_pSkill = fk_SnT_S
	  fk_SnT_SxT.fk_pTask  = fk_SnT_T
	attributes
	  SName  : Skill -> Varchar
	  TName  : Task -> Varchar
	  SonSxT : SkillxTask -> Varchar
	  TonSxT : SkillxTask -> Varchar
	  skill  : SkillNdFrTask -> Varchar
	  task   : SkillNdFrTask -> Varchar
	observation_equations
	  forall st. st.fk_pSkill.SName = st.SonSxT
	  forall st. st.fk_pTask.TName = st.TonSxT
	  forall snt. snt.fk_SnT_S.SName = snt.skill
	  forall snt. snt.fk_SnT_T.TName = snt.task
}

query qS_T_SnT_SumToSTJoy = literal : sS_T_SnT_Sum -> sSTJoy {
	entities //source entities: Skill SkillNeededForTask Task
		Skill -> {
			from
				ss : Skill
			return
				SName -> ss.SName
		}
		SkillNdFrTask -> {
			from
				snt : SkillNeededForTask
				sn  : Skill
				nt  : Task
			where
				snt.skill = sn.SName
				snt.task = nt.TName
			return
				skill -> snt.skill
				task  -> snt.task
		}
		SkillxTask -> {
			from
				xs : Skill
				xt : Task
			return
				SonSxT -> xs.SName
				TonSxT -> xt.TName
		}
		Task -> {
			from
				tt : Task
			return
				TName -> tt.TName
		}
	foreign_keys
		// fk_SnT_S   : SkillNdFrTask -> Skill
		fk_SnT_S   -> {ss -> sn}
		// fk_SnT_SxT : SkillNdFrTask -> SkillxTask
		fk_SnT_SxT -> {xs -> sn xt -> nt}
		// fk_SnT_T   : SkillNdFrTask -> Task
		fk_SnT_T   -> {tt -> nt}
	    // fk_pSkill  : SkillxTask -> Skill
		fk_pSkill  -> {ss -> xs}
		//fk_pTask   : SkillxTask -> Task
		fk_pTask   -> {tt -> xt}
}

instance iSTJoy = eval qS_T_SnT_SumToSTJoy iS_T_SnT_Sum


schema sSTSpn = literal : TypeSide {
	entities
	  Skill Task
	  SkillNdFrTask
	foreign_keys
	  fk_SnT_S   : SkillNdFrTask -> Skill
	  fk_SnT_T   : SkillNdFrTask -> Task
	attributes
	  SName  : Skill -> Varchar
	  TName  : Task -> Varchar
	  skill  : SkillNdFrTask -> Varchar
	  task   : SkillNdFrTask -> Varchar
	observation_equations
	  forall snt. snt.fk_SnT_S.SName = snt.skill
	  forall snt. snt.fk_SnT_T.TName = snt.task
}

query qS_T_SnT_SumToSTSpn = literal : sS_T_SnT_Sum -> sSTSpn {
	entities //source entities: Skill SkillNeededForTask Task
		Skill -> {
			from
				ss : Skill
			return
				SName -> ss.SName
		}
		SkillNdFrTask -> {
			from
				snt : SkillNeededForTask
				sn  : Skill
				nt  : Task
			where
				snt.skill = sn.SName
				snt.task = nt.TName
			return
				skill -> snt.skill
				task  -> snt.task
		}
		Task -> {
			from
				tt : Task
			return
				TName -> tt.TName
		}
	foreign_keys
		// fk_SnT_S   : SkillNdFrTask -> Skill
		fk_SnT_S   -> {ss -> sn}
		// fk_SnT_T   : SkillNdFrTask -> Task
		fk_SnT_T   -> {tt -> nt}
}

instance iSTSpn = eval qS_T_SnT_SumToSTSpn iS_T_SnT_Sum

// Export the instance iSTSpn to SQL
pragma pCleanUp = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"DROP TABLE IF EXISTS sts_SkillNdFrTask"
"DROP TABLE IF EXISTS sts_Skill"
"DROP TABLE IF EXISTS sts_Task"}

pragma eSTS = export_jdbc_instance iSTSpn "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" "sts_"
  { options varchar_length = 256 }

pragma pp2 = exec_jdbc "com.mysql.jdbc.Driver"	"jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" {
"SHOW  TABLES"}


// Bring the exported instance back in
instance iSTSpnImp = import_jdbc "com.mysql.jdbc.Driver" "jdbc:mysql://mysql.catinf.com:3306/ci_test?user=catinfcom&password=FDiUY!pr" : sSTSpn {
   // entities - create generators for each entity based on the primary key of each entity in the source database
   Skill -> "select id from sts_Skill"
   Task -> "select id from sts_Task"
   SkillNdFrTask -> "select id from sts_SkillNdFrTask"
   // foreign keys
   fk_SnT_S -> "select id, fk_SnT_S from sts_SkillNdFrTask"
   fk_SnT_T -> "select id, fk_SnT_T from sts_SkillNdFrTask"
   // attributes
   SName -> "select id, SName from sts_Skill"
   TName -> "select id, TName from sts_Task"
   skill -> "select id, skill from sts_SkillNdFrTask"
   task -> "select id, task from sts_SkillNdFrTask"
}


/*
constraints prdED = literal : sTS {
	forall t:Task s:Skill
	->
	exists ts:TaskSkill
	where
	  ts.Fk_Tsk_Skl = s
	  ts.Fk_Skl_Tsk = t
}

instance iTS0 = literal : sTS {
	generators
	    t1 t2 t3 t4 t5 t6 t7 t8 t9 : Task
	    s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 : Skill
	multi_equations
	    TName -> {t1 LaunchStartup, t2 BuildSWProduct, t3 WriteTutorial, t4 BuildPhrmColim, t5 BuildFncColim,
	              t6 WriteMathPaper, t7 TeachMath, t8 RunPhrmIntProject, t9 RunFincIntProject}
	    SName -> {s10 Math, s11 CompSci, s12 DBA, s13 Pharma, s14 Programming, s15 Teaching, s16 GrantWriting,
	    		  s17 Finance, s18 Management, s19 PaperWriting}
}*/

//instance iTS1 = chase prdED iTS0 2

// Now we do the analogous thing for tasks and skills.
// Populate the sTS TaskSkill relationship with the product Task x Skill. 
/*
query qTS_CoPr_to_TS = literal : getSchema sTS_CoPr -> sTS {
   entities
	Task -> {
		from
		  t : sT_Task
		return
		  TName -> t.sT_TName
	}
	Skill -> {
		from
		  s : sS_Skill
		return
		  SName -> s.sS_SName
	}
	TaskSkill -> {
		from
		  t0 : sT_Task
		  s0 : sS_Skill
		return
		  TofTSPair -> t0.sT_TName
		  SofTSPair -> s0.sS_SName
	}
   foreign_keys  // This effectively implements projections from skill, person pairs to skills and people: s <- (s0,p0) -> p
	  Fk_Tsk_Skl -> {s -> s0}
	  Fk_Skl_Tsk -> {t -> t0}
}

// Evaluate the query above using the instance on the coproduct.
instance iTS_from_TS_CoPr = eval qTS_CoPr_to_TS iTS_CoPr



instance iPS = literal : sPS {
	generators
		p1 p2 p3 p4 : Person
	    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 : Skill
	    ps1 ps2 ps3 ps4 ps5 ps6 ps7 ps8 ps9 ps10 ps11 ps12 ps13 ps14 ps15 ps16 ps17 ps18 ps19 : PersonSkill
	multi_equations
	    Fk_Prsn_Skl -> {ps1 s0, ps2 s1, ps3 s2, ps4 s2, ps5 s3, ps6 s5, ps7 s5, ps8 s5, ps9 s6,
	    				ps10 s6, ps11 s7, ps12 s8, ps13 s8, ps14 s8, ps15 s8, ps16 s9, ps17 s9, ps18 s9, 
	    				ps19 s9}
	    Fk_Skl_Prsn -> {ps1 p2, ps2 p3, ps3 p1, ps4 p4, ps5 p1, ps6 p1, ps7 p2, ps8 p3, ps9 p2,
	    				ps10 p3, ps11 p4, ps12 p1, ps13 p2, ps14 p3, ps15 p4, ps16 p1, ps17 p2, ps18 p3,  
	    				ps19 p4}
		PName -> {p1 Jane, p2 Joan, p3 Jim, p4 John}// Person -> Varchar
	    SName -> {s0 Math, s1 CompSci, s2 DBA, s3 Pharma, s4 Programming, s5 Teaching, s6 GrantWriting,
	    		  s7 Finance, s8 Management, s9 PaperWriting}
}

instance iTS = literal : sTS {
	generators
	    t1 t2 t3 t4 t5 t6 t7 t8 t9 : Task
	    s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 : Skill
	    ts1 ts2 ts3 ts4 ts5 ts6 ts7 ts8 ts9 ts10 ts11 ts12 ts13 ts14 ts15 ts16 ts17 ts18 ts19 ts20 ts21 ts22 : TaskSkill
	multi_equations
	    Fk_Tsk_Skl -> {ts1 s11, ts2 s14, ts3 s16, ts4 s19, ts5 s11, ts6 s14, ts7 s18, ts8 s14, ts9 s15, ts10 s19, 
	    			   ts11 s13, ts12 s14, ts13 s14, ts14 s17, ts15 s10, ts16 s19, ts17 s10, ts18 s15, ts19 s13, ts20 s18,
	    			   ts21 s17, ts22 s18}
	    Fk_Skl_Tsk -> {ts1 t1,  ts2 t1,  ts3 t1,  ts4 t1,  ts5 t2,  ts6 t2,  ts7 t2,  ts8 t3,  ts9 t3,  ts10 t3,  
	    			   ts11 t4,  ts12 t4,  ts13 t5,  ts14 t5,  ts15 t6,  ts16 t6,  ts17 t7,  ts18 t7,  ts19 t8,  ts20 t8,
	    			   ts21 t9,  ts22 t9}
	    TName -> {t1 LaunchStartup, t2 BuildSWProduct, t3 WriteTutorial, t4 BuildPhrmColim, t5 BuildFncColim,
	              t6 WriteMathPaper, t7 TeachMath, t8 RunPhrmIntProject, t9 RunFincIntProject}
	    SName -> {s10 Math, s11 CompSci, s12 DBA, s13 Pharma, s14 Programming, s15 Teaching, s16 GrantWriting,
	    		  s17 Finance, s18 Management, s19 PaperWriting}
}

// Glue sTS and sPS on the entity Skill
schema_colimit sTSP_CoLim = quotient sTS + sPS : TypeSide {
	entity_equations
	  sTS.Skill = sPS.Skill
	observation_equations
	  forall x. x.sTS_SName = x.sPS_SName
}*/
/*
instance iTSP_CoPr = coproduct
	sigma getMapping sTSP_CoLim sPS iPS
	sigma getMapping sTSP_CoLim sTS iTS
	: getSchema sTSP_CoLim
	{ options timeout=20 }

instance iTSP_Ovrlp = literal : getSchema sTSP_CoLim {
	generators
	   so0 so1 so2 so3 so4 so5 so6 so7 so8 so9 : sPS_Skill__sTS_Skill
}

transform tTSP_Ovrlp_to_PS = literal : iTSP_Ovrlp -> iTSP_CoPr {
  generators
	so0 -> s0
	so1 -> s1
	so2 -> s2
	so3 -> s3
	so4 -> s4
	so5 -> s5
	so6 -> s6
	so7 -> s7
	so8 -> s8
	so9 -> s9
}

transform tTSP_Ovrlp_to_TS = literal : iTSP_Ovrlp -> iTSP_CoPr {
  generators
	so0 -> s10
	so1 -> s11
	so2 -> s12
	so3 -> s13
	so4 -> s14
	so5 -> s15
	so6 -> s16
	so7 -> s17
	so8 -> s18
	so9 -> s19
}

instance iTSP_CoLim = coequalize tTSP_Ovrlp_to_PS tTSP_Ovrlp_to_TS
*/
